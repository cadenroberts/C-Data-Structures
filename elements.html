<!DOCTYPE HTML><html><head><title>2023 strict html/css portfolio project</title><meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" /><link rel="stylesheet" href="assets/css/main.css" /><noscript><link rel="stylesheet" href="assets/css/noscript.css" /> </noscript></head><body class="is-preload"><div id="page-wrapper"><header id="header"><h1><a href="index.html">Caden Roberts Portfolio</a></h1><nav><a href="#menu">Explore Code</a></nav></header><nav id="menu"><div class="inner"><h2>Menu</h2><ul class="links"><li><a href="index.html">Home</a></li><li><a href="elements.html">C++</a></li><li><a href="generic.html"> Python </a> </li> </ul> <a href="#" class="close"> Close </a> </div> </nav> <section id="wrapper"> <header> <div class="inner"> <h2> C++ </h2> <p> A collection of 27 C++ programming assignments, from Hello World, Classes, and Polymorphism, to Data Structures, Snakes and Ladders, and Sorting Algorithms. </p> </div> </header> <!-- Snake and Ladders Program --> <div class="wrapper"> <div class = "inner"> <blockquote> <h3 class="major">Snake and Ladders Program</h3> <p>Output is the best ending of each turn, and the total turns for the board. The following board is used for this assignment.</p> <a href="#" class="image"> <img src="images/image.jpeg" alt="" /> </blockquote> <p> <pre> <code>// Caden Roberts<br/>#include &#60iostream&#62<br/>class Board {<br/> public:<br/> int board[100]{0};<br/> Board() {}<br/> void tunnel(int start, int end) { board[start-1] = end - start; }<br/><br/> void minmovesguider(int position=1, int moves=0) {<br/> if (position<95){<br/> if (position>1) std::cout << "Turn end at " << position << ".\n";<br/> int best[6]{board[position]+1, board[position+1]+2, board[position+2]+3, board[position+3]+4, board[position+4]+5, board[position+5]+6};<br/> return minmovesguider(position+*std::max_element(best, best+6), moves+1);<br/> } else if (position<100){<br/> std::cout << "Turn end at " << position << ".\n";<br/> moves++;<br/> }<br/> std::cout << "Reached final square 100.\nMinimum moves for the board is " << moves << ".\n";<br/> }<br/><br/>};<br/><br/>int main () {<br/> Board Board;<br/> Board.tunnel(3,21);<br/> Board.tunnel(8,30);<br/> Board.tunnel(28,84);<br/> Board.tunnel(58,77);<br/> Board.tunnel(75,86);<br/> Board.tunnel(80,100);<br/> Board.tunnel(90,91);<br/> Board.tunnel(17, 13);<br/> Board.tunnel(88, 18);<br/> Board.tunnel(62,22);<br/> Board.tunnel(52, 29);<br/> Board.tunnel(57,40);<br/> Board.tunnel(95,51);<br/> Board.tunnel(97,79);<br/> Board.minmovesguider(1, 0);<br/> return 0;<br/>} </code> </pre> </p> </div> </div> <!-- Sorting Functions Program --> <div class="wrapper"> <div class="inner"> <blockquote> <h3 class="major"> Sorting Functions Program </h3> <p> An exam file take an input of size of an array to sort, then the array is created and all sorting function runtimes are compared. </p> </blockquote> <h3 class = "major"> Header Files </h3> <p> <pre> <code>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include &#60cmath&#62<br/>#include &#60thread&#62<br/>#include &#60cstdlib&#62<br/>#include &#60chrono&#62<br/>#include &#60ctime&#62<br/><br/>using namespace std;<br/>using namespace std::chrono;<br/><br/>struct sortRoutine {<br/> void (*function)( int *, size_t );<br/> const char * name;<br/>};<br/><br/>int *getRandomNumbers (size_t num, int seed);<br/>void printArray (int *array, size_t count);<br/>void disarrangeArray (int *array, size_t count, size_t numberOfChanges);<br/>bool checkSort (int *array, size_t count);<br/>duration&#60double&#62 sortAndTime (int* testArray, size_t theSize, sortRoutine theTest, bool print =false);<br/>/*************************<br/>** Sample Sort Functions Provided<br/>*************************/<br/>void shakerSort (int *array, size_t count);<br/>void cQuickSort (int *array, size_t count);<br/>void quickSortBook (int *array, size_t count);<br/><br/>/*************************<br/>** Student Created Sort Function<br/>*************************/<br/>void bubbleSort (int *array, size_t count);<br/>void selectionSort(int *data, size_t n);<br/>void insertionSort(int *data, size_t n);<br/>void bubbleSortOptimized (int *array, size_t count);<br/>void quickSort (int *array, size_t count);<br/>void mergeSort (int *array, size_t count);<br/>void quickSortNonRecursive (int *array, size_t count);<br/>void nonRecursiveMergeSort (int *array, size_t count);<br/>void quickSortThreaded (int *array, size_t count);<br/><br/>sortRoutine yourSortRoutines[] = {<br/> {shakerSort, "a sample Shaker Sort"},<br/> {quickSortBook, "the Quick Sort from the Book"},<br/> {bubbleSort, "the Bubble Sort"},<br/> {bubbleSortOptimized, "your Optimized Bubble Sort"},<br/> {selectionSort, "your Selection Sort"},<br/> {insertionSort, "your Insertion Sort"},<br/> {cQuickSort, "the C++ Built-in Quick Sort"},<br/> {quickSort, "your Quick Sort"},<br/> {quickSortNonRecursive, "your Non-Recursive Quick Sort"},<br/> {quickSortThreaded, "your Multi-Threaded Quick Sort"},<br/> {mergeSort, "your Merge Sort"},<br/> {nonRecursiveMergeSort, "your Non-Recursive Merge Sort"},<br/> {nullptr , nullptr }<br/>};<br/>long long checkSum;<br/><br/>int main(int argc, const char * argv[]) {<br/> size_t inputSize{0};<br/> char inputChar;<br/> cout &#60&#60 "CIST 004B Sorting Assignment. Worth 20 points\n\n" &#60&#60 flush;<br/> do {<br/> cout &#60&#60 "Enter the size of Array you wish to sort (not more than 100,000,000): ";<br/> cin &#62&#62 inputSize;<br/> if (inputSize > 100000000) cout &#60&#60 "Please try again!\n";<br/> } while (inputSize > 100000000 );<br/> do {<br/> cout &#60&#60 "Do you wish a single run (Y/N): ";<br/> cin &#62&#62 inputChar;<br/> inputChar = toupper (inputChar);<br/> } while (inputChar != 'Y' && inputChar != 'N');<br/> if (inputChar == 'Y'){<br/> for ( size_t i{0} ;yourSortRoutines[i].function != nullptr ; ++ i ){<br/> cout &#60&#60 fixed &#60&#60 setprecision(6);<br/> int* testArray = getRandomNumbers (inputSize, 0);<br/> cout &#60&#60 "\nNow executing " &#60&#60 yourSortRoutines[i].name &$60&#60 " of " &#60&#60 inputSize &#60&#60" items.\n";<br/> duration&#60double&#62 time_span_r = sortAndTime(testArray, inputSize, yourSortRoutines[i], true);<br/> cout &#60&#60 static_cast&#60char&#62(toupper(yourSortRoutines[i].name[0])) &#60&#60 &yourSortRoutines[i].name[1] &#60&#60 " took " &#60&#60 setw(7) &#60&#60 time_span_r.count() &#60&#60 " Seconds.\n";<br/> disarrangeArray (testArray, inputSize, inputSize*0.0005 +1);<br/> cout &#60&#60 "Now Executing " &#60&#60 yourSortRoutines[i].name &#60&#60 " of " &#60&#60 inputSize &#60&#60 " mostly (99.9%) sorted items.\n";<br/> time_span_r = sortAndTime(testArray, inputSize, yourSortRoutines[i], true);<br/> cout &#60&#60 static_cast&#60char&#62(toupper(yourSortRoutines[i].name[0])) &#60&#60 &yourSortRoutines[i].name[1] &#60&#60 " took " &#60&#60 setw(8) &#60&#60 time_span_r.count() &#60&#60 " Seconds.\nNow Executing " &#60&#60 yourSortRoutines[i].name &#60&#60 " of " &#60&#60 inputSize &#60&#60 " pre-sorted items.\n";<br/> time_span_r = sortAndTime(testArray, inputSize, yourSortRoutines[i], true);<br/> cout &#60&#60 static_cast&#60char&#62(toupper(yourSortRoutines[i].name[0])) &#60&#60 &ampyourSortRoutines[i].name[1] &#60&#60 " took " &#60&#60 setw(8) &#60&#60 time_span_r.count() &#60&#60 " Seconds.\n";<br/> delete[] (testArray-2);<br/> }<br/> cout &#60&#60 endl;<br/> } else {<br/> size_t ArraySize{0};<br/> time_t rawtime;<br/> cout &#60&#60 "\nTesting every Sort Routine with array sizes from 0 to " &#60&#60 inputSize &#60&#60 " numbers.\n";<br/> do {<br/> if (ArraySize % 100 == 1 ) {<br/> if (ArraySize == 1) cout &#60&#60 "Starting at:\t\t\t";<br/> time (&amprawtime);<br/> char str[26];<br/> cout &#60&#60 '\t' &#60&#60 ctime_r( &rawtime, str ) &#60&#60 setw(log10(inputSize)+1) &#60&#60 ArraySize-1 ;<br/> }<br/> if (ArraySize % 10 == 9 ) cout &#60&#60 " ." &#60&#60 flush;<br/> for ( size_t i{0} ;yourSortRoutines[i].function != nullptr ; ++ i ){<br/> int* testArray = getRandomNumbers (ArraySize, 0);<br/> sortAndTime(testArray, ArraySize, yourSortRoutines[i], true);<br/> delete[] (testArray-2);<br/> }<br/> } while(ArraySize++ < inputSize);<br/> cout &#60&#60 endl;<br/> time (&amprawtime);<br/> cout &#60&#60 "Finished at:\t\t\t\t" &#60&#60 ctime(&amprawtime) &#60&#60 endl;<br/> }<br/> return 0;<br/>}<br/><br/>void shakerSort (int *array, size_t count) {<br/> if (count <= 1) return;<br/> size_t p, i;<br/> for (p = 1; p <= count / 2; p++) {<br/> bool doneEarlyOptimization {true};<br/> for (i = p - 1; i < count - p; i++){<br/> if (array[i] > array[i+1]) {<br/> int temp = array[i+1];<br/> array[i+1] = array[i];<br/> array[i] = temp;<br/> doneEarlyOptimization = false;<br/> }<br/> }<br/> for (i = count - p - 1; i >= p; i--) {<br/> if (array[i] < array[i-1]) {<br/> int temp = array[i-1];<br/> array[i-1] = array[i];<br/> array[i] = temp;<br/> doneEarlyOptimization = false;<br/> }<br/> }<br/> if (doneEarlyOptimization) break;<br/> }<br/> return;<br/>}<br/><br/>int cQuickSortCompare (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); }<br/><br/>void cQuickSort (int *array, size_t count) {<br/>qsort (array, count, sizeof(int), cQuickSortCompare);<br/>return;<br/>}<br/><br/>void bubbleSort (int *array, size_t count) {<br/> if (count <= 1) return;<br/> for (int i = 0, a; i < count-1; i++) for (int j = 0; j < count-i-1; j++) if (array[j] > array[j+1]) {<br/> a = array[j];<br/> array[j] = array[j+1];<br/> array[j+1] = a;<br/> }<br/> return;<br/>}<br/><br/>void bubbleSortOptimized (int *array, size_t count){<br/> if (count <= 1) return;<br/> for (int i=0, a=1; i < count-1; i++, a=1) {<br/> for (int j = 0; j < count-i-1; j++) if (array[j] > array[j+1]) {<br/> a=array[j];<br/> array[j] = array[j+1];<br/> array[j+1]=a;<br/> a=0;<br/> }<br/> if (a) break;<br/> }<br/> return;<br/>}<br/><br/>void selectionSort(int *data, size_t n){<br/> size_t i, j, index_of_largest;<br/> int largest;<br/> if (n <= 1) return;<br/> for (i = n-1; i > 0; --i) {<br/> largest = data[0];<br/> index_of_largest = 0;<br/> for (j = 1; j <= i; ++j) if (data[j] > largest) {<br/> largest = data[j];<br/> index_of_largest = j;<br/> }<br/> largest = data[i];<br/> data[i] = data[index_of_largest];<br/> data[index_of_largest] = largest;<br/> }<br/>};<br/><br/>void insertionSort(int *data, size_t n){<br/> int key, j;<br/> for (int i = 1; i < n; i++) {<br/> key = data[i];<br/> j = i - 1;<br/> while (j >= 0 && data[j] > key) {<br/> data[j+1] = data[j];<br/> j--;<br/> }<br/> data[j+1] = key;<br/> }<br/>};<br/><br/>void mergeSort(int data[ ], size_t n){<br/> size_t n1, n2;<br/> if (n > 1) {<br/> n1 = n / 2;<br/> n2 = n - n1;<br/> mergeSort(data, n1);<br/> mergeSort((data + n1), n2);<br/> int *temp = new int[n1+n2];<br/> size_t copied = 0, copied1 = 0, copied2 = 0, i;<br/> while ((copied1 < n1) && (copied2 < n2)) {<br/> if (data[copied1] < (data + n1)[copied2]) temp[copied++] = data[copied1++];<br/> else temp[copied++] = (data + n1)[copied2++];<br/> }<br/> while (copied1 < n1) temp[copied++] = data[copied1++];<br/> while (copied2 < n2) temp[copied++] = (data+n1)[copied2++];<br/> for (i = 0; i < n1+n2; ++i) data[i] = temp[i];<br/> delete [ ] temp;<br/> }<br/>}<br/><br/>void nonRecursiveMergeSort(int* array, size_t count) {<br/> size_t n1, n2;<br/> for (size_t size = 1; size < count; size *= 2) for (size_t left_start = 0; left_start < count; left_start += 2 * size) {<br/> n1 = size;<br/> if (left_start + n1 > count) n1 = count - left_start;<br/> n2 = size;<br/> if (left_start + n1 + n2 > count) n2 = count - left_start - n1;<br/> int temp[n1 + n2];<br/> size_t i1 = 0, i2 = 0;<br/> for (size_t i = 0; i < n1 + n2; ++i) {<br/> if (i1 < n1 && i2 < n2) {<br/> if (array[left_start + i1] < array[left_start + n1 + i2]) {<br/> temp[i] = array[left_start + i1];<br/> ++i1;<br/> } else {<br/> temp[i] = array[left_start + n1 + i2];<br/> ++i2;<br/> } else if (i1 < n1) {<br/> temp[i] = array[left_start + i1];<br/> ++i1;<br/> } else {<br/> temp[i] = array[left_start + n1 + i2];<br/> ++i2;<br/> }<br/> }<br/> for (size_t i = 0; i < n1 + n2; ++i) array[left_start + i] = temp[i];<br/> }<br/>}<br/><br/>void quickSort (int *array, size_t count){<br/> if (count <= 1) return;<br/> int pivot = array[0], swapper;<br/> size_t i = 1, j = count - 1;<br/> while (i <= j) {<br/> while (i < count && array[i] < pivot) i++;<br/> while (j > 0 && array[j] >= pivot) j--;<br/> if (i < j) {<br/> swapper = array[j];<br/> array[j] = array[i];<br/> array[i] = swapper;<br/> }<br/> }<br/> swapper = array[0];<br/> array[0] = array[j];<br/> array[j] = swapper;<br/> quickSort(array, j);<br/> quickSort(array + j + 1, count - j - 1);<br/>}<br/><br/>void quickSortNonRecursive(int *array, size_t count) {<br/> if (count <= 1) return;<br/> int stack[count];<br/> int top = -1;<br/> stack[++top] = 0;<br/> stack[++top] = count - 1;<br/> while (top >= 0) {<br/> int end = stack[top--];<br/> int start = stack[top--];<br/> int pivot = array[start];<br/> int i = start + 1;<br/> int j = end;<br/> while (i <= j) {<br/> while (i <= end && array[i] < pivot) i++;<br/> while (j > start && array[j] >= pivot) j--;<br/> if (i < j) {<br/> int temp = array[i];<br/> array[i] = array[j];<br/> array[j] = temp;<br/> }<br/> }<br/> int temp = array[start];<br/> array[start] = array[j];<br/> array[j] = temp;<br/> if (j - 1 > start) {<br/> stack[++top] = start;<br/> stack[++top] = j - 1;<br/> }<br/> if (j + 1 < end) {<br/> stack[++top] = j + 1;<br/> stack[++top] = end;<br/> }<br/> }<br/>}<br/><br/>void quickSortThreaded (int *array, size_t count){<br/> static size_t threads;<br/> if (count <= 1) return;<br/> int pivot = array[0], swapper;<br/> size_t i = 1, j = count - 1;<br/> while (i <= j) {<br/> while (i < count && array[i] < pivot) i++;<br/> while (j > 0 && array[j] >= pivot) j--;<br/> if (i < j) {<br/> swapper = array[j];<br/> array[j] = array[i];<br/> array[i] = swapper;<br/> }<br/> }<br/> swapper = array[0];<br/> array[0] = array[j];<br/> array[j] = swapper;<br/> if (threads<500){<br/> threads+=2;<br/> thread leftThread(quickSortThreaded, array, j);<br/> thread rightThread(quickSortThreaded, array + j + 1, count - j - 1);<br/> leftThread.join();<br/> rightThread.join();<br/> } else {<br/> quickSortThreaded(array, j);<br/> quickSortThreaded(array + j + 1, count - j - 1);<br/> }<br/>};<br/><br/>void partitionBook(int data[ ], size_t n, size_t& pivot_index) {<br/> int pivot = data[0];<br/> size_t too_big_index = 1;<br/> size_t too_small_index = n-1;<br/> while (too_big_index <= too_small_index) {<br/> while ((too_big_index < n) && (data[too_big_index] <= pivot)) too_big_index++;<br/> while (data[too_small_index] > pivot) too_small_index--;<br/> if (too_big_index < too_small_index){<br/> int temp = data[too_small_index];<br/> data[too_small_index] = data[too_big_index];<br/> data[too_big_index] = temp;<br/> }<br/> }<br/> pivot_index = too_small_index;<br/> data[0] = data[pivot_index];<br/> data[pivot_index] = pivot;<br/>}<br/><br/>void quickSortBook(int data[ ], size_t n) {<br/> size_t pivot_index;<br/> size_t n1;<br/> size_t n2;<br/> if (n > 1) {<br/> partitionBook(data, n, pivot_index);<br/> n1 = pivot_index;<br/> n2 = n - n1 - 1;<br/> quickSortBook(data, n1);<br/> quickSortBook((data + pivot_index + 1), n2);<br/> }<br/>}<br/><br/>duration&#60double&#62 sortAndTime (int* testArray, size_t theSize, sortRoutine theTest, bool print){<br/> high_resolution_clock::time_point t1 = high_resolution_clock::now();<br/> theTest.function (testArray, theSize);<br/> high_resolution_clock::time_point t2 = high_resolution_clock::now();<br/> if ( !checkSort (testArray, theSize) && print){<br/> cout &#60&#60 "Array size of: " &#60&#60 theSize &#60&#60 " contents after " &#60&#60 theTest.name &#60&#60 " completed.\n";<br/> printArray (testArray, theSize);<br/> }<br/> return t2 - t1;<br/>}<br/><br/>int* getRandomNumbers(size_t num, int seed =0) {<br/> int *arr = nullptr;<br/> checkSum = 0LL;<br/> arr = new int[num +4];<br/> arr[0] = arr [1] = 999999;<br/> arr += 2;<br/> srand(seed);<br/> int rnum = static_cast&#60int&#62(num);<br/> for (int count = 0; count < num; count++){<br/> arr[count] = rand() % (rnum*11) - rnum*11/2;<br/> checkSum += static_cast &#60long long&#62(arr[count]);<br/> }<br/> arr[num+1] = arr [num] = -999999;<br/> return arr;<br/>}<br/><br/>bool checkSort( int *a, size_t count) {<br/> if (count < 1) return true;<br/> bool sorted = true;<br/> long long testCheckSum =0;<br/> for ( size_t i{0} ; i < count-1 ; ++i){<br/> testCheckSum += static_cast<long long>(a[i]);<br/> if ( a[i] > a[i+1] ) {<br/> sorted = false;<br/> cout &#60&#60 "Error Encountered!\n\tArray [" &#60&#60 setw(log10(count)+1) &#60&#60 i &#60&#60 "] = " &#60&#60 a[i] &#60&#60 "\n\tArray [" &#60&#60 setw(log10(count)+1) &#60&#60 i+1 &#60&#60 "] = " &#60&#60 a[i+1] &#60&#60 endl;<br/> break;<br/> }<br/> }<br/> if (testCheckSum+ static_cast&#60long long&#62(a[count-1]) != checkSum ) {<br/> cout &#60&#60"\nChecksum of Array does not match. Orginal: " &#60&#60 checkSum &#60&#60 " New: " &#60&#60 testCheckSum+ static_cast&#60long long&#62(a[count-1]) &#60&#60 "\nNot All numbers not present in the resulting array!\n";<br/> printArray(a, count);<br/> sorted = false;<br/> }<br/> if ( *(a-1) != 999999 or *(a-2) != 999999 ){<br/> cout &#60&#60 "Error Encountered!\n\tArray [-2] is " &#60&#60 *(a-2) &#60&#60 "\n\tArray [-1] is " &#60&#60 *(a-1) &#60&#60 "\n\tBoth should be -999999. You wrote Before the start of the array\n";<br/> sorted = false;<br/> }<br/> if ( a[count] != -999999 or a[count+1] != -999999 ){<br/> cout &#60&#60 "Error Encountered!\n\tArray ["&#60&#60 setw(log10(count)+1) &#60&#60 count &#60&#60 "] = " &#60&#60 a[count] &#60&#60 "\n\tArray [" &#60&#60 setw(log10(count)+1) &#60&#60 count+1 &#60&#60 "] = " &#60&#60 a[count+1] &#60&#60 "\n\tBoth should be 999999. You wrote After the end of the array\n";<br/> sorted = false;<br/> }<br/> return sorted;<br/>}<br/><br/>void disarrangeArray (int *array, size_t count, size_t numberOfChanges){<br/> if (count < 10 || count < numberOfChanges*4 ) return;<br/> srand(42);<br/> for ( ; numberOfChanges > 0 ; --numberOfChanges ){<br/> size_t x = rand()%(count+1);<br/> size_t y = rand()%(count+1);<br/> int tmp = array[x];<br/> array[x] = array[y];<br/> array[y] = tmp;<br/> }<br/> return;<br/>}<br/><br/>void printArray (int* array, size_t count){<br/> for ( size_t i{0} ; i < count ; ++i) cout &#60&#60 "Array [" &#60&#60 setw(log10(count)+1) &#60&#60 i &#60&#60 "] = " &#60&#60 array[i] &#60&#60 endl;<br/>} </code> </pre> </p> <!-- Hashtable Program --> <div class="wrapper"> <div class="inner"> <blockquote><h3 class="major"> Chained Hashing Program </h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (file availible upon request to show code functionality). </p> </blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef TABLE1_H<br/>#define TABLE1_H<br/>#include &#60stdlib.h&#62<br/><br/>template &#60class Item&#62<br/>struct Node {<br/> Item data;<br/> Node *link;<br/>};<br/><br/>template &#60class RecordType&#62<br/>class Table {<br/> public:<br/> enum { TABLE_SIZE = 811 };<br/> Table( );<br/> Table(const Table& source);<br/> ~Table( );<br/> void insert(const RecordType& entry);<br/> void remove(int key);<br/> void operator =(const Table& source);<br/> void find(int key, bool& found, RecordType& result) const;<br/> bool is_present(int key) const;<br/> size_t size( ) const { return total_records; }<br/> private:<br/> Node&#60RecordType&#62 *hash_table[TABLE_SIZE];<br/> size_t total_records;<br/> size_t hash_function(int key) const;<br/> Node&#60RecordType&#62* find_node(int key) const;<br/>};<br/><br/>#include "table2.tpp.h"<br/>#endif</code></pre></p> <h3 class = "major">TPP/CPP Files</h3> <p><pre><code>#include &#60assert.h&#62<br/><br/>template &#60class RecordType&#62<br/>size_t Table&#60RecordType&#62::hash_function(int key) const { return (key % TABLE_SIZE); }<br/><br/>template &#60class RecordType&#62<br/>Table&#60RecordType&#62::Table() {<br/> total_records = 0;<br/> for (size_t i = 0; i < TABLE_SIZE; i++) hash_table[i] = nullptr;<br/>}<br/><br/>template &#60class RecordType&#62<br/>Table&#60RecordType&#62::~Table() {<br/> total_records = 0;<br/> for (size_t i = 0; i < TABLE_SIZE; i++) {<br/> Node&#60RecordType&#62* current = hash_table[i];<br/> while (current != nullptr) {<br/> Node&#60RecordType&#62* temp = current;<br/> current = current->link;<br/> delete temp;<br/> }<br/> }<br/>}<br/><br/>template &#60class RecordType&#62<br/>Table&#60RecordType&#62::Table(const Table&#60RecordType&#62& source) {<br/> for (size_t i = 0; i < TABLE_SIZE; i++) {<br/> hash_table[i] = nullptr;<br/> Node&#60RecordType&#62* cursor = source.hash_table[i];<br/> Node&#60RecordType&#62* precursor = nullptr;<br/> while (cursor != nullptr) {<br/> Node&#60RecordType&#62* new_node = new Node&#60RecordType&#62{cursor->data, cursor->link};<br/> if (precursor == nullptr) hash_table[i] = new_node;<br/> else precursor->link=new_node;<br/> precursor = new_node;<br/> cursor = cursor->link;<br/> }<br/> }<br/> total_records = source.total_records;<br/>}<br/><br/>template &#60class RecordType&#62<br/>void Table&#60RecordType&#62::insert(const RecordType& entry) {<br/> assert(entry.key >= 0);<br/> if (find_node(entry.key) == nullptr) {<br/> hash_table[hash_function(entry.key)] = new Node&#60RecordType&#62{entry, hash_table[hash_function(entry.key)]};<br/> total_records++;<br/> } else find_node(entry.key)->data=entry;<br/>}<br/><br/>template&#60class RecordType&#62<br/>void Table&#60RecordType&#62::remove(int key) {<br/> assert(key >= 0);<br/> Node&#60RecordType&#62* cursor = hash_table[hash_function(key)], * precursor = nullptr;<br/> while (cursor != nullptr && cursor->data.key != key) {<br/> precursor = cursor;<br/> cursor = cursor->link;<br/> }<br/> if (cursor == nullptr) return;<br/> if (precursor == nullptr) hash_table[hash_function(key)] = cursor->link;<br/> else precursor->link = cursor->link;<br/> delete cursor;<br/> total_records--;<br/>}<br/><br/>template &#60class RecordType&#62<br/>void Table&#60RecordType&#62::operator =(const Table&#60RecordType&#62& source) {<br/> if (this != &source) {<br/> for (size_t i = 0; i < TABLE_SIZE; i++) {<br/> while (hash_table[i] != nullptr) {<br/> Node&#60RecordType&#62* head = hash_table[i];<br/> hash_table[i] = hash_table[i]->link;<br/> delete head;<br/> }<br/> Node&#60RecordType&#62* cursor = source.hash_table[i], * precursor = nullptr;<br/> while (cursor != nullptr) {<br/> precursor = new Node&#60RecordType&#62{cursor->data, hash_table[i]};<br/> hash_table[i] = precursor;<br/> cursor = cursor->link;<br/> }<br/> }<br/> total_records = source.total_records;<br/> }<br/>}<br/><br/>template &#60class RecordType&#62<br/>bool Table&#60RecordType&#62::is_present(int key) const { return (find_node(key)!=nullptr); }<br/><br/>template &#60class RecordType&#62<br/>Node&#60RecordType&#60* Table&#60RecordType&#62::find_node(int key) const {<br/> assert(key >= 0);<br/> for (Node&#60RecordType&#62* cursor = hash_table[hash_function(key)]; ; cursor = cursor->link) if (cursor==nullptr||(cursor->data.key==key)) return cursor;<br/>}<br/><br/>template &#60class RecordType&#62<br/>void Table&#60RecordType&#62::find(int key, bool& found, RecordType& result) const {<br/> found = is_present(key);<br/> if (found) result = find_node(key)->data;<br/>}</code></pre></p> <!-- Priority Heap Program --> <div class="wrapper"> <div class="inner"> <blockquote><h3 class="major">Priority Heap Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (file availible upon request to show code functionality).</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef PQUEUE_H<br/>#define PQUEUE_H<br/>#include &#60stdlib.h&#62<br/><br/>class PriorityQueue {<br/> public:<br/> typedef int Item;<br/> static const size_t CAPACITY = 5000;<br/> PriorityQueue( );<br/> void insert(const Item& entry, unsigned int priority);<br/> Item get_front( );<br/> size_t size( ) const { return many_items; }<br/> bool is_empty( ) const { return (many_items == 0); }<br/> void print_tree(const char message[ ] = "", size_t i = 0) const;<br/> private:<br/> struct OneItemInfo {<br/> Item data;<br/> unsigned int priority;<br/> };<br/> OneItemInfo heap[CAPACITY];<br/> size_t many_items;<br/> bool is_leaf(size_t i) const;<br/> size_t parent_index(size_t i) const;<br/> unsigned int parent_priority(size_t i) const;<br/> size_t big_child_index(size_t i) const;<br/> unsigned int big_child_priority(size_t i) const;<br/> void swap_with_parent(size_t i);<br/>};<br/><br/>#endif</code></pre></p> <h3 class = "major">TPP/CPP Files</h3> <p><pre><code>#include &#60cassert&#62<br/>#include &#60iomanip&#62<br/>#include &#60iostream&#62<br/>#include &#60cmath&#62<br/>#include "pqueue2.h"<br/>using namespace std;<br/><br/>PriorityQueue::PriorityQueue( ) {<br/> many_items=0;<br/> return;<br/>}<br/><br/>void PriorityQueue::insert(const Item& entry, unsigned int priority) {<br/> assert (many_items < CAPACITY);<br/> size_t new_index = many_items;<br/> heap[new_index].data = entry;<br/> heap[new_index].priority = priority;<br/> many_items++;<br/> while (new_index > 0 && parent_priority(new_index) < priority) {<br/> swap_with_parent(new_index);<br/> new_index = parent_index(new_index);<br/> }<br/> return;<br/>}<br/><br/>PriorityQueue::Item PriorityQueue::get_front( ) {<br/> if (is_empty()) return PriorityQueue::Item(NULL);<br/> Item result = heap[0].data;<br/> heap[0] = heap[--many_items];<br/>size_t i = 0;<br/> while (!is_leaf(i)) {<br/> size_t big_child = big_child_index(i);<br/> if (!(heap[i].priority < heap[big_child].priority)) break;<br/> swap_with_parent(big_child);<br/> i = big_child;<br/> }<br/> return result;<br/>}<br/><br/>bool PriorityQueue::is_leaf(size_t i) const {<br/> if (i<many_items) return ((2 * i) + 1 > many_items - 1);<br/> return false;<br/>}<br/><br/>size_t PriorityQueue::parent_index(size_t i) const {<br/> if ((i > 0) && (i < many_items)) return (i - 1) / 2;<br/> return size_t (NULL);<br/>}<br/><br/>unsigned int PriorityQueue::parent_priority(size_t i) const {<br/> if ((i > 0) && (i < many_items)) return heap[parent_index(i)].priority;<br/> return unsigned (NULL);<br/>}<br/><br/>size_t PriorityQueue::big_child_index(size_t i) const {<br/> size_t a=2*i+1, b=heap[a].priority, c=heap[a+1].priority;<br/> return (a+1 >= many_items || b > c) ? a : a+1;<br/>}<br/><br/>unsigned int PriorityQueue::big_child_priority(size_t i) const {<br/> size_t a=2*i+1;<br/> unsigned int b=heap[a].priority, c=heap[a+1].priority;<br/> return (a+1 >= many_items || b > c) ? b : c;<br/>}<br/><br/>void PriorityQueue::swap_with_parent(size_t i) {<br/> std::swap(heap[parent_index(i)], heap[i]);<br/> return;<br/>}<br/><br/>void PriorityQueue::print_tree(const char message[ ], size_t i) const {<br/> const char NO_MESSAGE[ ] = "";<br/> size_t depth;<br/> if (message[0] != '\0') cout << message << endl;<br/> if (i >= many_items) cout << "NO NODES." << endl;<br/> else {<br/> depth = int(log(double(i+1))/log(2.0));<br/> cout << setw(static_cast<int>(depth)*4) << "" << heap[i].data << " (priority " << heap[i].priority << ")" << endl;<br/> if (2*i + 1 < many_items) print_tree(NO_MESSAGE, 2*i + 1);<br/> if (2*i + 2 < many_items) print_tree(NO_MESSAGE, 2*i + 2);<br/>}<br/>}</code></pre></p> <!-- Priority Queue Program --> <div class="wrapper"> <div class="inner"> <blockquote><h3 class="major">Tree Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (file availible upon request to show code functionality).</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef BAG6_H<br/>#define BAG6_H<br/>#include &#60cstdlib&#62<br/>#include "bintree.h"<br/>namespace main_savitch_10 {<br/>template &#60class Item&#62<br/>class bag {<br/> public:<br/> typedef std::size_t size_type;<br/> typedef Item value_type;<br/> bag( ) : root_ptr(nullptr) {};<br/> bag(const bag& source);<br/> ~bag( );<br/> size_type erase(const Item& target);<br/> bool erase_one(const Item& target);<br/> void insert(const Item& entry);<br/> void operator +=(const bag& addend);<br/> void operator =(const bag& source);<br/> size_type size( ) const;<br/> size_type count(const Item& target) const;<br/> private:<br/> binary_tree_node&#60Item&#62 *root_ptr;<br/> void insert_all(binary_tree_node&#60Item&#62* addroot_ptr);<br/>};<br/><br/>template &#60class Item&#62<br/>bag&#60Item&#62 operator +(const bag&#60Item&#62& b1, const bag&#60Item&#62& b2);<br/>}<br/><br/>#include "bag6.tpp.h"<br/>#endif</code></pre></p> <h3 class = "major">TPP/CPP Files</h3> <p><pre><code>#include &#60cassert&#62<br/>#include &#60cstdlib&#62<br/>#include "bag6.h"<br/>namespace main_savitch_10 {<br/><br/>template &#60class Item&#62<br/>void bst_remove_max(binary_tree_node&#60Item&#62*& root_ptr, Item& removed) {<br/> if (root_ptr->right() == nullptr) {<br/> removed = root_ptr->data();<br/> binary_tree_node&#60Item&#62* old_root_ptr = root_ptr;<br/> root_ptr = root_ptr->left();<br/> delete old_root_ptr;<br/> } else bst_remove_max(root_ptr->right(), removed);<br/>}<br/><br/>template &#60class Item&#62<br/>bool bst_remove(binary_tree_node&#60Item&#62*& root_ptr, const Item& target) {<br/> binary_tree_node&#60Item&#62 *oldroot_ptr;<br/> if (root_ptr == nullptr) return false;<br/> if (target &#60 root_ptr-&#62data( )) return bst_remove(root_ptr->left( ), target);<br/> if (target > root_ptr->data( )) return bst_remove(root_ptr->right( ), target);<br/> if (root_ptr->left( ) == nullptr) {<br/> oldroot_ptr = root_ptr;<br/> root_ptr = root_ptr->right( );<br/> delete oldroot_ptr;<br/> return true;<br/> }<br/> bst_remove_max(root_ptr->left( ), root_ptr->data( ));<br/> return true;<br/>}<br/><br/>template &#60class Item&#62<br/>typename bag&#60Item&#62::size_type bst_remove_all (binary_tree_node&#60Item&#62*& root_ptr, const Item& target) {<br/> binary_tree_node&#60Item&#62 *oldroot_ptr;<br/> if (root_ptr == nullptr) return 0;<br/> if (target &#60 root_ptr-&#62data( )) return bst_remove_all(root_ptr->left(), target);<br/> if (target > root_ptr->data( )) return bst_remove_all(root_ptr->right(), target);<br/> if (root_ptr->left( ) == nullptr) {<br/> oldroot_ptr = root_ptr;<br/> root_ptr = root_ptr->right( );<br/> delete oldroot_ptr;<br/> return 1;<br/> } else if (root_ptr->right() == nullptr) {<br/> oldroot_ptr = root_ptr;<br/> root_ptr = root_ptr->left();<br/> delete oldroot_ptr;<br/> return 1 + bst_remove_all(root_ptr, target);<br/> }<br/> oldroot_ptr = root_ptr->left();<br/> while (oldroot_ptr->right() != nullptr) oldroot_ptr = oldroot_ptr->right();<br/> root_ptr->set_data(oldroot_ptr->data());<br/> return bst_remove_all(root_ptr, root_ptr->data())+1;<br/>}<br/><br/>template &#60class Item&#62<br/> bag&#60Item&#62::bag(const bag&#60Item&#62&amp source) { root_ptr = tree_copy(source.root_ptr); }<br/><br/>template &#60class Item&#62<br/>bag&#60Item&#62::~bag( ) { tree_clear(root_ptr); }<br/><br/>template &#60class Item&#62<br/>typename bag&#60Item&#62::size_type bag&#60Item&#62::size( ) const { return tree_size(root_ptr); }<br/><br/>template &#60class Item&#62<br/>void bag&#60Item&#62::insert(const Item& entry) {<br/> binary_tree_node&#60Item&#62 *cursor;<br/> if (root_ptr == nullptr) {<br/> root_ptr = new binary_tree_node&#60Item&#62(entry);<br/> return;<br/> } else {<br/> cursor = root_ptr;<br/> while (true) {<br/> if (entry <= cursor->data( )) {<br/> if (cursor->left( ) == nullptr) {<br/> cursor->left( ) = new binary_tree_node&#60Item&#62(entry);<br/> return;<br/> } else cursor = cursor->left( );<br/> } else {<br/> if (cursor->right( ) == nullptr) {<br/> cursor->right( ) = new binary_tree_node&#60Item&#62(entry);<br/> return;<br/> } else cursor = cursor->right( );<br/> }<br/> }<br/> }<br/>}<br/><br/>template &#60class Item&#62<br/>typename bag&#60Item&#62::size_type bag&#60Item&#62::count(const Item& target) const {<br/> size_type answer = 0;<br/> binary_tree_node&#60Item&#62 *cursor;<br/> cursor = root_ptr;<br/> while (cursor != nullptr) {<br/> if (target &#60 cursor-&#62data()) cursor = cursor->left();<br/> else if (target > cursor->data()) cursor = cursor->right();<br/> else {<br/> ++answer;<br/> cursor = cursor->left();<br/> }<br/> }<br/> return answer;<br/>}<br/><br/>template &#60class Item&#62<br/>typename bag&#60Item&#62::size_type bag&#60Item&#62::erase(const Item& target) { return bst_remove_all(root_ptr, target); }<br/><br/>template &#60class Item&#62<br/>bool bag&#60Item&#62::erase_one(const Item& target) { return bst_remove(root_ptr, target); }<br/><br/>template &#60class Item&#62<br/>void bag&#60Item&#62::operator =(const bag&#60Item&#62&amp source) {<br/> if (root_ptr == source.root_ptr) return;<br/> tree_clear(root_ptr);<br/> root_ptr = tree_copy(source.root_ptr);<br/>}<br/><br/>template &#60class Item&#62<br/>void bag&#60Item&#62::operator +=(const bag&#60Item&#62& addend) {<br/> if (root_ptr == addend.root_ptr) {<br/> bag&#60Item&#62 copy = addend;<br/> insert_all(copy.root_ptr);<br/> } else insert_all(addend.root_ptr);<br/>}<br/><br/>template &#60class Item&#62<br/>bag&#60Item&#62 operator +(const bag&#60Item&#62& b1, const bag&#60Item&#62& b2) {<br/> bag&#60Item&#62 answer = b1;<br/> answer += b2;<br/> return answer;<br/>}<br/><br/>template &#60class Item&#62<br/>void bag&#60Item&#62::insert_all(binary_tree_node&#60Item&#62* addroot_ptr) {<br/> if (addroot_ptr != nullptr) {<br/> insert(addroot_ptr->data( ));<br/> insert_all(addroot_ptr->left( ));<br/> insert_all(addroot_ptr->right( ));<br/> }<br/>}<br/>}</code></pre></p> <p><pre><code>#include &#60cassert&#62<br/>#include &#60cstdlib&#62<br/>#include &#60iomanip&#62<br/>#include &#60iostream&#62<br/>#include "bintree.h"<br/><br/>namespace main_savitch_10 {<br/><br/>template &#60class Process, class BTNode&#62<br/>void inorder(Process f, BTNode* node_ptr) {<br/> if (node_ptr != nullptr) {<br/> inorder(f, node_ptr->left( ));<br/> f( node_ptr->data( ) );<br/> inorder(f, node_ptr->right( ));<br/> }<br/>}<br/><br/>template &#60class Process, class BTNode&#62<br/>void postorder(Process f, BTNode* node_ptr) {<br/> if (node_ptr != nullptr) {<br/> postorder(f, node_ptr->left( ));<br/> postorder(f, node_ptr->right( ));<br/> f(node_ptr->data( ));<br/> }<br/>}<br/><br/>template &#60class Process, class BTNode&#62<br/>void preorder(Process f, BTNode* node_ptr) {<br/> if (node_ptr != nullptr) {<br/> f( node_ptr->data( ) );<br/> preorder(f, node_ptr->left( ));<br/> preorder(f, node_ptr->right( ));<br/> }<br/>}<br/><br/>template &#60class Item, class SizeType&#62<br/>void print(binary_tree_node&#60Item&#62* node_ptr, SizeType depth) {<br/> if (node_ptr != nullptr) {<br/> print(node_ptr->right( ), depth+1);<br/> std::cout &#60&#60 std::setw(4*depth) &#60&#60 "" &#60&#60 node_ptr->data( ) &#60&#60 std::endl;<br/> print(node_ptr->left( ), depth+1);<br/> }<br/>}<br/><br/>template &#60class Item&#62<br/>void tree_clear(binary_tree_node&#60Item&#62*& root_ptr) {<br/> binary_tree_node&#60Item&#62* child;<br/> if (root_ptr != nullptr) {<br/> child = root_ptr->left( );<br/> tree_clear( child );<br/> child = root_ptr->right( );<br/> tree_clear( child );<br/> delete root_ptr;<br/> root_ptr = nullptr;<br/> }<br/>}<br/><br/>template &#60class Item&#62<br/>binary_tree_node&#60Item&#62* tree_copy(const binary_tree_node&#60Item&#62* root_ptr) {<br/> binary_tree_node&#60Item&#62 *l_ptr, *r_ptr;<br/> if (root_ptr == nullptr) return nullptr;<br/> else {<br/> l_ptr = tree_copy( root_ptr->left( ) );<br/> r_ptr = tree_copy( root_ptr->right( ) );<br/> return new binary_tree_node&#60Item&#62( root_ptr->data( ), l_ptr, r_ptr);<br/> }<br/>}<br/><br/>template &#60class Item&#62<br/>size_t tree_size(const binary_tree_node&#60Item&#62* node_ptr) {<br/> if (node_ptr == nullptr) return 0;<br/> else return 1 + tree_size(node_ptr->left( )) + tree_size(node_ptr->right( ));<br/>}<br/><br/>} </code></pre></p> <!-- Recursive Functions Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Recursive Functions Program</h3><p>Output is a test of 4 recursive functions, and a time comparison between iterative and recursive Fibonacci Calls! One function, triangle, prints an asterisk triangle, and another, numberes, sections of a book. For Bears, the game starts when I give you some bears. You can then give back some bears, but you must follow these rules (where n is the number of bears that you have: if n is even, then you may give back exactly n/2 bears, if n is divisible by 3 or 4, then you may multiply the last two digits of n and give back this many bears, and if n is divisible by 5, then you may give back exactly 42 bears. The goal of the game is to end up with EXACTLY 42 bears. The fibonacci functions are the last 2. </p></blockquote> <p><pre><code>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/><br/>using namespace std;<br/>using namespace std::chrono;<br/><br/>void triangle(std::ostream& outs, int m, unsigned int n) {<br/> if (m <= n || n == 0) {<br/> for (int i = 0; i < (n > 0 ? m : 0); i++) outs << "*";<br/> outs << "\n";<br/> triangle(outs, m + (n > 0), n - 1);<br/> for (int i = 0; i < (n > 0 ? m : 0); i++) outs << "*";<br/> outs << "\n";<br/> }<br/>}<br/><br/>void numbers(ostream& outs, const string& prefix, unsigned int levels) {<br/> if (levels == 0) {<br/> outs &#60&#60 prefix &#60&#60 "\n";<br/> return;<br/> }<br/> for (char c = '1'; c <= '9'; c++) numbers(outs, prefix + c + ".", levels - 1);<br/>}<br/><br/>bool bears(int n) {<br/> if (n < 42) return false;<br/> else if ((n == 42)||(n % 2 == 0 && bears(n / 2))||(n % 5 == 0 && bears(n - 42))||(n % 10 != 0 && (n % 100) / 10 != 0 && n % 3 == 0 && bears(n - (n % 10) * ((n % 100) / 10)))||(n % 4 == 0 && bears(n - (n % 10) * ((n % 100) / 10)))) return true;<br/> else return false;<br/>}<br/><br/>int fib_recursive(int n) {<br/> if (n <= 1) return n;<br/> return fib_recursive(n - 1) + fib_recursive(n - 2);<br/>}<br/><br/>int fib_iterative(int n) {<br/> if(n == 1 || n == 2) return 1;<br/> int A[2][2] = { { 1, 1 },{ 1, 0 } };<br/> int B[2][2] = { { 1, 1 },{ 1, 0 } };<br/> int temp[2][2];<br/> while (n >= 2) {<br/> for (int i = 0; i < 2; i++) for (int k = 0; k < 2; k++) {<br/> temp[i][k] = 0;<br/> for (int j = 0; j < 2; j++) temp[i][k] += A[i][j] * B[j][k];<br/> }<br/> for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) B[i][j] = temp[i][j];<br/> n--;<br/> }<br/> return B[0][1];<br/>}<br/><br/>int main() {<br/> cout << "Caden Roberts\t4/1/23\tCIST04B\n\nPerforming Triangle Test...\n";<br/> triangle(cout, 1, 15);<br/> cout << "\nPerforming Numbers Test...\n";<br/> numbers(cout, "Bio ", 2);<br/> cout << "\nPerforming Bears Test...\n";<br/> int array[5]{250, 42, 84, 53, 41};<br/> for (int i = 0; i<5; i++) {<br/> cout << "Bears " << array[i];<br/> if (bears(array[i])) cout << " is true!\n";<br/> else cout << " is false!\n";<br/> }<br/> cout << "\nPerforming Fibonacci time tests...\n n Recursive Time Iterative Time\n";<br/> for (int n = 1; n <= 45; n++) {<br/> high_resolution_clock::time_point start_time_r = high_resolution_clock::now();<br/> int result_r = fib_recursive(n);<br/> high_resolution_clock::time_point end_time_r = high_resolution_clock::now();<br/> duration&#60float&#62 time_span_r = end_time_r - start_time_r;<br/> high_resolution_clock::time_point start_time_i = high_resolution_clock::now();<br/> int result_i = fib_iterative(n);<br/> high_resolution_clock::time_point end_time_i = high_resolution_clock::now();<br/> duration&#60float&#62 time_span_i = end_time_i - start_time_i;<br/> cout &#60&#60 right &#60&#60 setw(3) &#60&#60 n &#60&#60 right &#60&#60 setw(14) &#60&#60 result_r &#60&#60 right &#60&#60 setw(14) &#60&#60 fixed &#60&#60 setprecision(9) &#60&#60 time_span_r.count() &#60&#60 right &#60&#60 setw(14) &#60&#60 result_i &#60&#60 right &#60&#60 setw(14) &#60&#60 fixed &#60&#60 setprecision(9) &#60&#60 time_span_i.count() &#60&#60 endl;<br/> }<br/> return 0;<br/>}</code></pre></p> </div> </div> <!-- Priority Queue Program --> <div class="wrapper"> <div class="inner"> <blockquote><h3 class="major">Priority Queue Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. Here, and for the only time on this site, except by request, an example of user-defined type exam code is given.</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef pqueue1_HPP<br/>#define pqueue1_HPP<br/>#include &#60stdlib.h&#62<br/><br/>template &#60typename Item&#62<br/>struct Node {<br/> Item data;<br/> Node * link = nullptr;<br/>unsigned int priority;<br/>};<br/><br/>template &#60class Item&#62<br/>class PriorityQueue {<br/> public:<br/> PriorityQueue( );<br/> PriorityQueue(const PriorityQueue<Item>& source);<br/> ~PriorityQueue( );<br/> void operator =(const PriorityQueue&#60Item&#62& source);<br/> size_t size( ) const;<br/> void insert(const Item& entry, unsigned int priority);<br/> Item get_front( );<br/> bool is_empty( ) const { return head_ptr == nullptr; }<br/> private:<br/> Node&#60Item&#62 * head_ptr = nullptr; <br/>};<br/><br/>#include "pqueue1.tpp.h"<br/>#endif</code></pre></p> <h3 class = "major">TPP/CPP Files</h3> <p><pre><code>#include &#60stdio.h&#62<br/>#include "pqueue1.hpp"<br/>#include &#60assert.h&#62<br/><br/>template &#60typename Item&#62<br/>PriorityQueue&#60Item&#62::PriorityQueue( ) { head_ptr = nullptr; }template &#60typename Item&#62<br/>PriorityQueue&#60Item&#62::PriorityQueue(const PriorityQueue& source) {<br/> head_ptr = nullptr;<br/> Node&#60Item&#62* tail_ptr;<br/> Node&#60Item&#62* source_ptr;<br/> if (source.head_ptr == nullptr) head_ptr = nullptr;<br/> else {<br/> head_ptr = new Node&#60Item&#62;<br/> head_ptr->data = source.head_ptr->data;<br/> head_ptr->priority = source.head_ptr->priority;<br/> head_ptr->link = nullptr;<br/> tail_ptr = head_ptr;<br/> source_ptr = source.head_ptr->link;<br/> while (source_ptr != nullptr) {<br/> tail_ptr->link = new Node&#60Item&#62;<br/> tail_ptr = tail_ptr->link;<br/> tail_ptr->data = source_ptr->data;<br/> tail_ptr->priority = source_ptr->priority;<br/> tail_ptr->link = nullptr;<br/> source_ptr = source_ptr->link;<br/> }<br/> }<br/>}<br/><br/>template &#60typename Item&#62<br/>PriorityQueue<Item>::~PriorityQueue( ) {<br/> Node&#60Item&#62* remove_ptr;<br/> while (head_ptr != nullptr) {<br/> remove_ptr = head_ptr;<br/> head_ptr = head_ptr->link;<br/> delete remove_ptr;<br/> }<br/>}<br/><br/>template &#60typename Item&#62<br/>void PriorityQueue&#60Item&#62::operator =(const PriorityQueue&#60Item&#62& source) {<br/> if (this == &source) return;<br/> while (!is_empty()) get_front();<br/> Node&#60Item&#62* src_ptr = source.head_ptr;<br/> while (src_ptr != nullptr) {<br/> insert(src_ptr->data, src_ptr->priority);<br/> src_ptr = src_ptr->link;<br/> }<br/>}<br/><br/>template &#60typename Item&#62<br/>size_t PriorityQueue&#60Item&#62::size() const {<br/> size_t count = 0;<br/> Node<Item>* curr = head_ptr;<br/> while (curr != nullptr) {<br/> count++;<br/> curr = curr->link;<br/> }<br/> return count;<br/>}<br/><br/>template &#60typename Item&#62<br/>void PriorityQueue&#60Item&#62::insert(const Item& entry, unsigned int priority) {<br/> Node&#60Item&#62* new_node = new Node&#60Item&#62;<br/> new_node->data = entry;<br/> new_node->priority = priority;<br/> new_node->link = nullptr;<br/> if (head_ptr == nullptr || priority > head_ptr->priority) {<br/> new_node->link = head_ptr;<br/> head_ptr = new_node;<br/> } else {<br/> Node&#60Item&#62* cursor = head_ptr;<br/> while (cursor->link != nullptr && priority &#60= cursor-&#62link-&#62priority) cursor = cursor->link;<br/> new_node->link = cursor->link;<br/> cursor->link = new_node;<br/> }<br/>}<br/><br/>template &#60typename Item&#62<br/>Item PriorityQueue<Item>::get_front() {<br/> assert(!is_empty());<br/> Item front = head_ptr->data;<br/> Node&#60Item&#62* temp_ptr = head_ptr;<br/> head_ptr = head_ptr->link;<br/> delete temp_ptr;<br/> return front;<br/>}</code></pre></p> <p><pre><code>#include &#60iostream&#62<br/>#include &#60string.h&#62<br/>#include "pqueue1.hpp"<br/><br/>typedef int Test;<br/>const size_t MANY_TESTS = 4;<br/>const int POINTS[MANY_TESTS+1] = { 20, 10, 4, 3, 3 };<br/>const char DESCRIPTION[MANY_TESTS+1][256] = { "tests for the PriorityQueue class", "simple tests of insert and get_front", "Testing for possible heap leaks", "Testing the copy constructor", "Testing the assignment operator" };<br/>const size_t BORDER_SIZE = 2*sizeof(double);<br/>const char GARBAGE = 'g';<br/>const char BORDER = 'b';<br/>static size_t memory_used_now = 0;<br/><br/>void* operator new(size_t size) {<br/> char *whole_block;<br/> size_t *size_spot;<br/> char *front_border;<br/> char *middle;<br/> char *back_border;<br/> size_t i;<br/> whole_block = (char *) malloc(2*BORDER_SIZE + size);<br/> if (whole_block == nullptr) {<br/> std::cout &#60&#60 "Insufficient memory for a call to the new operator.\n";<br/> exit(0);<br/> }<br/> size_spot = (size_t *) whole_block;<br/> front_border = (char *) (whole_block + sizeof(size_t));<br/> middle = (char *) (whole_block + BORDER_SIZE);<br/> back_border = middle + size;<br/> *size_spot = size;<br/> for (i = 0; i < BORDER_SIZE - sizeof(size_t); i++) front_border[i] = BORDER;<br/> for (i = 0; i < size; i++) middle[i] = GARBAGE;<br/> for (i = 0; i < BORDER_SIZE; i++) back_border[i] = BORDER;<br/> memory_used_now += size;<br/> return middle;<br/>}<br/><br/>void operator delete(void* p) noexcept(true) {<br/> char *whole_block;<br/> size_t *size_spot;<br/> char *front_border;<br/> char *middle;<br/> char *back_border;<br/> size_t i;<br/> size_t size;<br/> bool corrupt;<br/> whole_block = ((char *) (p)) - BORDER_SIZE;<br/> size_spot = (size_t *) whole_block;<br/> size = *size_spot;<br/> front_border = (char *) (whole_block + sizeof(size_t));<br/> middle = (char *) (whole_block + BORDER_SIZE);<br/> back_border = middle + size;<br/> corrupt = false;<br/> for (i = 0; i < BORDER_SIZE - sizeof(size_t); i++) if (front_border[i] != BORDER) corrupt = true;<br/> for (i = 0; i < BORDER_SIZE; i++) if (back_border[i] != BORDER) corrupt = true;<br/> std::cout << "The delete operator has detected that the program wrote\nbeyond the ends of a block of memory that was allocated\nby the new operator. Program will be halted.\n"<br/> exit(0);<br/> } else {<br/> for (i = 0; i < size + 2*BORDER_SIZE; i++)<br/> whole_block[i] = GARBAGE;<br/> free(whole_block);<br/> memory_used_now -= size;<br/> }<br/>}<br/><br/>bool correct(PriorityQueue<Test>& test, size_t n, int items[]) {<br/> size_t i;<br/> bool answer = true;<br/> if (test.size( ) != n || test.is_empty( ) != (n == 0)) answer = false;<br/> else for (i = 0; answer && (i < n); i++) if (items[i] != test.get_front( )) answer = false;<br/> std::cout &#60&#60 (answer ? "Test passed.\n" : "Test failed.\n") &#60&#60 std::endl;<br/> return answer;<br/>}<br/><br/>int test1( ) {<br/> const size_t TEST_SIZE = 400;<br/> const unsigned int PRIORITY_LIMIT = 100;<br/> PriorityQueue&#60Test&#62 test;<br/> int items[8] = { 100, 200, 3, 4, 5, 6, 8, 7 };<br/> int occurs[PRIORITY_LIMIT];<br/> int rand_items[TEST_SIZE];<br/> char test_letter = 'A';<br/> int i;<br/> unsigned int priority;<br/> std::cout &#60&#60 test_letter++ &#60&#60 ". Testing size and is_empty for an empty priority queue.\n";<br/> if (!correct(test, 0, items)) return 0;<br/> std::cout &#60&#60 test_letter++ &#60&#60 ". Adding one item to the queue, and then testing\n is_empty, size, and get_front.\n";<br/> test.insert(100, 1);<br/> if (!correct(test, 1, items)) return 0;<br/> std::cout &#60&#60 test_letter++ &#60&#60 ". Inserting two items (first has higher priority).\n Then checking that both items come out correctly.\n";<br/> test.insert(100, 10);<br/> test.insert(200, 5);<br/> if (!correct(test, 2, items)) return 0;<br/> std::cout &#60&#60 test_letter++ &#60&#60 ". Inserting two items (second has higher priority).\n Then checking that both items come out correctly.\n";<br/> test.insert(200, 5);<br/> test.insert(100, 10);<br/> if (!correct(test, 2, items)) return 0;<br/> std::cout &#60&#60 test_letter++ &#60&#60 ". Inserting eight items with priorities of\n 8, 10, 3, 3, 8, 6, 10, 6 (in that order)\n Then checking that all items come out correctly.\n";<br/> test.insert(3, 8);<br/> test.insert(100, 10);<br/> test.insert(8, 3);<br/> test.insert(7, 3);<br/> test.insert(4, 8);<br/> test.insert(5, 6);<br/> test.insert(200, 10);<br/> test.insert(6, 6);<br/> if (!correct(test, 8, items)) return 0;<br/> std::cout &#60&#60 test_letter++ &#60&#60 ". Inserting " &#60&#60 TEST_SIZE << " random items with random\n priorities, and checking that all items come out right.\n";<br/> for (priority = 0; priority < PRIORITY_LIMIT; priority++) occurs[priority] = 0;<br/> for (i = 0; i < TEST_SIZE; i++) {<br/> priority = (unsigned) (rand( ) % 100);<br/> test.insert((int) priority, priority);<br/> occurs[priority]++;<br/> }<br/> priority = PRIORITY_LIMIT-1;<br/> for (i = 0; i < TEST_SIZE; i++) {<br/> while (occurs[priority] == 0) priority--;<br/> rand_items[i] = (int) priority;<br/> occurs[priority]--;<br/> }<br/> if (!correct(test, TEST_SIZE, rand_items)) return 0;<br/> return POINTS[1];<br/>}<br/><br/>int test2( ) {<br/> const size_t TEST_SIZE = 200;<br/> PriorityQueue&#60Test&#62 test, empty;<br/> PriorityQueue&#60Test&#62* pq_ptr;<br/> size_t base_usage;<br/> int i;<br/> int next;<br/> std::cout &#60&#60 "Checking for possible heap leak. This could occur if the assignment operator, get_front, or\nthe destructor does not correctly release memory.\nTesting for heap leak in get_front..." &#60&#60 std::flush;<br/> base_usage = memory_used_now;<br/> for (i = 0; i < TEST_SIZE; i++) test.insert(i, unsigned(i));<br/> for (i = 0; i < TEST_SIZE; i++) next = test.get_front( );<br/> if (memory_used_now != base_usage) {<br/> std::cout &#60&#60 "\n Test failed. Probable heap leak in get_front.\n";<br/> return 0;<br/> }<br/> else std::cout &#60&#60 "passed.\n";<br/> std::cout &#60&#60 "Testing for heap leak in destructor ... " &#60&#60 std::flush;<br/> pq_ptr = new PriorityQueue&#60Test&#62;<br/> for (i = 0; i &#60 TEST_SIZE; i++) pq_ptr-&#62insert(i, unsigned(i));<br/> delete pq_ptr;<br/> if (memory_used_now != base_usage) {<br/> std::cout &#60&#60 "\n Test failed. Possible heap leak in copy constructor.\n";<br/> return 0;<br/> }<br/> else std::cout &#60&#60 "passed.\nTesting for heap leak in assignment operator ... " &#60&#60 std::flush;<br/> for (i = 0; i < TEST_SIZE; i++) test.insert(i, unsigned(i));<br/> test = empty;<br/> if (memory_used_now != base_usage) {<br/> std::cout &#60&#60 "\n Test failed. Possible heap leak in assignment operator.\n";<br/> return 0;<br/> }<br/> else std::cout &#60&#60 "passed.\nNo heap leaks found.\n"<br/> return POINTS[2];<br/>}<br/><br/>int test3( ) {<br/> PriorityQueue&#60Test&#62 test;<br/> int items[4] = { 1, 2, 3, 4 };<br/> std::cout &#60&#60 "A. Testing that copy constructor works okay for empty queue..." &#60&#60 std::flush;<br/> PriorityQueue copy1(test);<br/> if (!correct(copy1, 0, items)) return 0;<br/> std::cout &#60&#60 "B. Testing copy constructor with 4-item queue..." &#60&#60 std::flush;<br/> test.insert(1, 100);<br/> test.insert(2, 50);<br/> test.insert(3, 25);<br/> test.insert(4, 10);<br/> PriorityQueue copy2(test);<br/> test.insert(5, 80);<br/> if (!correct(copy2, 4, items)) return 0;<br/> std::cout &#60&#60 "Copy constructor seems okay.\n";<br/> return POINTS[3];<br/>}<br/><br/>int test4( ) {<br/> PriorityQueue&#60Test&#62 test;<br/> int items[4] = { 1, 2, 3, 4 };<br/> char *oldbytes = new char[sizeof(PriorityQueue&#60Test&#62)];<br/> char *newbytes = new char[sizeof(PriorityQueue&#60Test&#62)];<br/> int i;<br/> std::cout &#60&#60 "A. Testing that assignment operator works okay for empty queue..." &#60&#60 std::flush;<br/> PriorityQueue&#60Test&#62 copy1;<br/> copy1.insert(1,1);<br/> copy1 = test;<br/> if (!correct(copy1, 0, items)) return 0;<br/> std::cout &#60&#60 "B. Testing assignment operator with 4-item queue..." &#60&#60 std::flush;<br/> test.insert(1, 100);<br/> test.insert(2, 50);<br/> test.insert(3, 25);<br/> test.insert(4, 10);<br/> PriorityQueue&#60Test&#62 copy2;<br/> copy2 = test;<br/> test.insert(5, 80);<br/> if (!correct(copy2, 4, items)) return 0;<br/> std::cout << "C. Testing assignment operator for a self-assignment..." << std::flush;<br/> memcpy(oldbytes, &test, sizeof(PriorityQueue&#60Test&#62));<br/> test = test;<br/> memcpy(newbytes, &test, sizeof(PriorityQueue&#60Test&#62));<br/> for (i=0; i &#60 sizeof(PriorityQueue&#60Test&#62); i++) if (oldbytes[i] != newbytes[i]) {<br/> std::cout << "failed.\n";<br/> return 0;<br/> }<br/> std::cout << "passed.\nAssignment operator seems okay.\n";<br/> return POINTS[4];<br/>}<br/><br/>int run_a_test(int number, const char message[], int test_function( ), int max) {<br/> int result;<br/> std::cout &#60&#60 "\nSTART OF TEST " &#60&#60 number &#60&#60 ":\n" &#60&#60 message &#60&#60 " (" &#60&#60 max &#60&#60 " points).\n";<br/> result = test_function( );<br/> if (result > 0) std::cout &#60&#60 "Test " &#60&#60 number &#60&#60 " got " &#60&#60 result &#60&#60 " points out of a possible " &#60&#60 max &#60&#60 ".\n";<br/> else std::cout << "Test " << number << " failed.\n";<br/> std::cout << "END OF TEST " << number << ".\n\n";<br/> return result;<br/>}<br/><br/>int main( ) {<br/> int sum = 0;<br/> std::cout &#60&#60 "Running " &#60&#60 DESCRIPTION[0] &#60&#60 std::endl;<br/> sum += run_a_test(1, DESCRIPTION[1], test1, POINTS[1]);<br/> sum += run_a_test(2, DESCRIPTION[2], test2, POINTS[2]);<br/> sum += run_a_test(3, DESCRIPTION[3], test3, POINTS[3]);<br/> sum += run_a_test(4, DESCRIPTION[4], test4, POINTS[4]);<br/> std::cerr &#60&#60 "\nYOUR RESULTS:\nYou have successfully earned " &#60&#60 sum &#60&#60 " points out of a possible " &#60&#60 POINTS[0] &#60&#60 " points.\n\nIf you submit this PriorityQueue to Canvas now, this part of the \ngrade could be as high as " &#60&#60 static_cast &#60int&#62 ((sum* 10.0f)/POINTS[0]) &#60&#60 " points out of 10 points.\n\n";<br/> return EXIT_SUCCESS;<br/>}</code></pre></p> <!-- N Queens Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">N Queens Program</h3> <p> N Queens is a challenge where an N by N board must have N Queens placed on it's board without any of them being able to attack one another (no adjacency or diagonal lines).</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef MAIN_SAVITCH_Stack3_H<br/>#define MAIN_SAVITCH_Stack3_H<br/>#include &#60cstdlib&#62<br/><br/>namespace main_savitch_7A {<br/><br/>template &#60typename Item&#62<br/>struct node { <br/> node(Item initdata = Item( ), node&#60Item&#62* initlink = nullptr){data=initdata;link=initlink;}<br/> Item data;<br/> node&#60Item&#62 * link;<br/>};<br/><br/>template &#60typename Item&#62<br/>class Stack {<br/> public:<br/>Stack( ) { Top=nullptr; many_nodes = 0; }<br/> ~Stack();<br/> bool empty( ) const { return (many_nodes == 0); }<br/> size_t size( ) const { return many_nodes; }<br/> void push(const Item& entry);<br/> Item pop( );<br/> Item top( ) const;<br/> Item peek(size_t index);<br/> private:<br/> node&#60Item&#62 *Top;<br/> size_t many_nodes;<br/> };<br/><br/>}<br/><br/>#include "stack3.tpp.h"<br/>#endif</code></pre></p> <h3 class = "major">TPP/CPP Files</h3> <p><pre><code>#include &#60cassert&#62<br/>#include "stack3.h"<br/>namespace main_savitch_7A {<br/><br/>template &#60typename Item&#62<br/>Stack&#60Item&#62::~Stack() {<br/> node&#60Item&#62* now;<br/> while (Top != nullptr){<br/> now = Top;<br/> Top = Top->link;<br/> delete now;<br/> }<br/> many_nodes=0;<br/>}<br/><br/>template &#60class Item&#62<br/>void Stack&#60Item&#62::push(const Item& entry) {<br/> Top = new node&#60Item&#62(entry, Top);<br/> many_nodes++;<br/>}<br/><br/>template &#60class Item&#62<br/><br/>Item Stack&#60Item&#62::pop( ) {<br/> assert(size() > 0);<br/> Item popped = Top->data;<br/> node&#60Item&#62* temp = Top;<br/> Top = Top->link;<br/> delete temp;<br/> many_nodes--;<br/> return popped;<br/>}<br/><br/>template &#60class Item&#62<br/>Item Stack&#60Item&#62::top( ) const {<br/> assert(size()>0);<br/> return Top->data;<br/>}<br/><br/>template &#60class Item&#62<br/><br/>Item Stack&#60Item&#62::peek(size_t index) {<br/> assert(index>=1 && index<=size());<br/> node&#60Item&#62 * i = Top;<br/> for (size_t a = 1; a < index ; a++) i=i->link;<br/> return i->data;<br/>}<br/>}</code></pre></p> <p><pre><code>#include &#60cassert&#62<br/>#include &#60iostream&#62<br/>#include "stack3.h"<br/>using namespace std;<br/>using namespace main_savitch_7A;<br/><br/>void print_solution( Stack&#60unsigned int&#62& choices ) {<br/> size_t maxSize {choices.size( )};<br/> cout << "Solution for n = " << choices.size( ) << endl;<br/> for (size_t i = 1 ; i < maxSize; i++ ) cout << "=="; cout <<"="<<endl;<br/> for (size_t i = 1 ; !choices.empty( ); i++) {<br/> unsigned int col = choices.pop( );<br/> for ( int r=1 ; r<=maxSize ; r++)<br/> cout << (r == col? "Q " : "- ") << " Queen in row " << i << ", column " << col << endl;<br/> }<br/> for (size_t i = 1 ; i < maxSize; i++ ) cout << "==";<br/> cout <<"="<<endl;<br/>}<br/><br/> bool is_conflict( Stack&#60unsigned int&#62& choices ) {<br/> unsigned int i;<br/> unsigned int newqueen = choices.top( );<br/> unsigned int other;<br/> for (i = 2; i <= choices.size( ); i++) {<br/> other = choices.peek(i);<br/> if ((newqueen == other) || (newqueen+(i-1) == other) || (newqueen-(i-1) == other)) return true;<br/> }<br/> return false;<br/>}<br/><br/>void queens(unsigned int nQueens) {<br/> Stack&#60unsigned int&#62 choices;<br/> bool success = false;<br/> assert (nQueens >= 1);<br/> choices.push(1);<br/> while (!success && !choices.empty( )) {<br/> if (is_conflict(choices)) {<br/> while (!choices.empty() && choices.top() == nQueens) { choices.pop(); }<br/>if (!choices.empty()) {<br/> unsigned int top_choice = choices.top();<br/> choices.pop();<br/> top_choice++;<br/> choices.push(top_choice);<br/> }<br/> }<br/> else if (choices.size( ) == nQueens) success = true;<br/> else choices.push(1);<br/> }<br/> if (success) print_solution(choices);<br/> else cout << "No solutions were found." << endl;<br/>}<br/><br/>int main( ) {<br/> unsigned int n;<br/> cout << "Caden Roberts\t3/23/23\tCIST04B\n"Please enter n for the n-queens problem (n >= 1): ";<br/> cin >> n;<br/> queens(n);<br/> return 0;<br/>} </code></pre></p> <!-- Templates Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Templated Linked List Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (Not included but availible upon request to show code functionality)</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef MAIN_SAVITCH_NODE2_H<br/>#define MAIN_SAVITCH_NODE2_H<br/>#include &#60cstdlib&#62<br/>#include &#60iterator&#62<br/>namespace main_savitch_6B<br/>{<br/>template &#60class Item&#62<br/>class node {<br/> public:<br/> node(const Item& init_data=Item( ), node* init_link=nullptr) {data_field = init_data; link_field = init_link; }<br/> Item& data( ) { return data_field; }<br/> node* link( ) { return link_field; }<br/> void set_data(const Item& new_data) { data_field = new_data; }<br/> void set_link(node* new_link) { link_field = new_link; }<br/> const Item& data( ) const { return data_field; }<br/> const node* link( ) const { return link_field; }<br/> private:<br/> Item data_field;<br/> node *link_field;<br/>};<br/>}<br/><br/>#endif</code></pre></p> <p><pre><code>#ifndef MAIN_SAVITCH_SEQUENCE4_H<br/>#define MAIN_SAVITCH_SEQUENCE4_H<br/>#include "node2.h"<br/>#include &#60cstdlib&#62<br/>namespace main_savitch_6B {<br/>template &#60class Item&#62<br/>class sequence {<br/> public:<br/> sequence( );<br/> sequence(const sequence& source);<br/> ~sequence( );<br/> void start( );<br/> void advance( );<br/> void insert(const Item& entry);<br/> void attach(const Item& entry);<br/> void operator =(const sequence& source);<br/> void remove_current( );<br/> size_t size( ) const { return many_nodes; }<br/> bool is_item( ) const { return (cursor != nullptr); }<br/> Item current( ) const;<br/> private:<br/> node&#60Item&#62 *head_ptr;<br/> node&#60Item&#62 *tail_ptr;<br/> node&#60Item&#62 *cursor;<br/> node&#60Item&#62 *precursor;<br/> size_t many_nodes;<br/>};<br/>}<br/><br/>#include "sequence4.tpp.h"<br/>#endif</code></pre></p> <h3 class = "major">TPP Files</h3> <p><pre><code>// sequence4.tpp.h<br/>// Templated Linked List Program<br/>// Created by Caden Roberts on 3/16/23.<br/>#include "sequence4.h"<br/>#include "assert.h"<br/>using namespace main_savitch_6B;<br/>template &#60class Item&#62<br/>sequence&#60Item&#62::sequence() {<br/> head_ptr = nullptr;<br/> tail_ptr = nullptr;<br/> cursor = nullptr;<br/> precursor = nullptr;<br/> many_nodes = 0;<br/>}<br/>template &#60typename Item&#62<br/>sequence&#60Item&#62::sequence(const sequence& source) {<br/> head_ptr = tail_ptr = cursor = precursor = nullptr;<br/> many_nodes = 0;<br/> node&#60Item&#62 *tail_copy = nullptr;<br/> for (node&#60Item&#62 *p = source.head_ptr; p != nullptr; p = p->link()) {<br/> node&#60Item&#62 *new_node = new node&#60Item&#62(p->data());<br/> if (tail_copy == nullptr) head_ptr = new_node;<br/> else tail_copy->set_link(new_node);<br/> tail_copy = new_node;<br/> if (p == source.cursor) cursor = new_node;<br/> if (p == source.precursor) precursor = new_node;<br/> ++many_nodes;<br/> }<br/> tail_ptr = tail_copy;<br/>}<br/>template &#60typename Item&#62<br/>sequence&#60Item&#62::~sequence() {<br/> while (head_ptr != nullptr) {<br/> node&#60Item&#62* removed_node = head_ptr;<br/> head_ptr = head_ptr->link();<br/> delete removed_node;<br/> }<br/> many_nodes = 0;<br/>}<br/>template &#60typename Item&#62<br/>void sequence&#60Item&#62::start() {<br/>cursor = head_ptr;<br/>precursor = nullptr;<br/>}<br/>template &#60typename Item&#62<br/>void sequence&#60Item&#62::advance() {<br/> if (cursor != nullptr) {<br/> precursor=cursor;<br/> cursor=cursor->link();<br/> } else if (head_ptr != nullptr) {<br/> precursor = tail_ptr;<br/> cursor = nullptr;<br/> }<br/>}<br/>template &#60typename Item&#62<br/>void sequence&#60Item&#62::insert(const Item& entry) {<br/> if (cursor == nullptr) {<br/> cursor = new node&#60Item&#62(entry, head_ptr);<br/> if (many_nodes == 0) tail_ptr = cursor;<br/> head_ptr = cursor;<br/> precursor = nullptr;<br/> } else {<br/> cursor = new node&#60Item&#62(entry, cursor);<br/> if (precursor == nullptr) head_ptr = cursor;<br/> else precursor->set_link(cursor);<br/> }<br/> ++many_nodes;<br/>}<br/>template &#60typename Item&#62<br/>void sequence&#60Item&#62::attach(const Item& entry) {<br/> if (cursor==nullptr) {<br/> if (tail_ptr != nullptr) {<br/> tail_ptr->set_link(new node&#60Item&#62(entry));<br/> precursor = tail_ptr;<br/> cursor = tail_ptr = tail_ptr->link();<br/> } else cursor = tail_ptr = head_ptr = new node&#60Item&#62(entry);<br/> } else {<br/> precursor = cursor;<br/> cursor->set_link(new node&#60Item&#62(entry, cursor->link()));<br/> if (cursor == tail_ptr) tail_ptr = cursor->link();<br/> cursor = cursor->link();<br/> }<br/> many_nodes++;<br/>}<br/>template &#60typename Item&#62<br/>void sequence&#60Item&#62::operator=(const sequence& source) {<br/> if (this == &source) return;<br/> while (head_ptr != nullptr) {<br/> node&#60Item&#62* removed_node = head_ptr;<br/> head_ptr = head_ptr->link();<br/> delete removed_node;<br/> }v many_nodes = 0;<br/> const node&#60Item&#62 * source_ptr = source.head_ptr;<br/> head_ptr = tailptr = nullptr;<br/> if (source_ptr == nullptr) return;<br/> tail_ptr = head_ptr = new node&#60Item&#62(source_ptr->data( ), head_ptr);<br/> source_ptr = source_ptr->link( );<br/> while (source_ptr != nullptr) {<br/> tail_ptr->set_link(new node&#60Item&#62(source_ptr->data( ), tail_ptr->link( )));<br/> tail_ptr = tail_ptr->link( );<br/> source_ptr = source_ptr->link( );<br/> }<br/> many_nodes = source.many_nodes;<br/> if (source.cursor == nullptr) {<br/> cursor = nullptr;<br/> precursor = nullptr;<br/> } else {<br/> node&#60Item&#62* p = head_ptr;<br/> node&#60Item&#62* source_p = source.head_ptr;<br/> while (source_p != source.cursor) {<br/> p = p->link();<br/> source_p = source_p->link();<br/> }<br/> cursor = p;<br/> precursor = nullptr;<br/> if (p != head_ptr) {<br/> precursor = head_ptr;<br/> while (precursor->link() != p) precursor = precursor->link();<br/> }<br/> }<br/>}<br/>template &#60typename Item&#62<br/>void sequence&#60Item&#62::remove_current() {<br/> if (cursor == nullptr && precursor == nullptr) return;<br/> if (cursor == head_ptr) {<br/> head_ptr = head_ptr->link();<br/> delete cursor;<br/> cursor = head_ptr;<br/> if (head_ptr == nullptr) tail_ptr = nullptr;<br/> } else {<br/> precursor->set_link(cursor->link());<br/> if (cursor == tail_ptr) tail_ptr = precursor;<br/> delete cursor;<br/> cursor = precursor->link();<br/> }<br/> --many_nodes;<br/>}<br/>template &#60typename Item&#62<br/>Item sequence&#60Item&#62::current() const {<br/> assert(is_item());<br/> return cursor->data();<br/>}</code></pre></p> <!-- Linked List Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Linked List Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (Not included but availible upon request to show code functionality)</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef MAIN_SAVITCH_NODE1_H<br/>#define MAIN_SAVITCH_NODE1_H<br/>namespace main_savitch_5<br/>{<br/>class node {<br/> public:<br/> typedef double value_type;<br/> node( const value_type& init_data = value_type( ), node* init_link = nullptr ) {<br/> data_field = init_data;<br/> link_field = init_link; <br/> }<br/> void set_data(const value_type& new_data) { data_field = new_data; }<br/> void set_link(node* new_link) { link_field = new_link; }<br/> value_type data( ) const { return data_field; }<br/> const node* link( ) const { return link_field; }<br/> node* link( ) { return link_field; }<br/> private:<br/> value_type data_field;<br/> node* link_field;<br/>};<br/>}<br/><br/>#endif</code></pre></p> <p><pre><code>#ifndef MAIN_SAVITCH_SEQUENCE3_H<br/>#define MAIN_SAVITCH_SEQUENCE3_H<br/>#include "node1.hpp"<br/>#include &#60cstdlib&#62<br/>namespace main_savitch_5 {<br/>typedef double value_type;<br/>class sequence {<br/> public:<br/> sequence( );<br/> sequence(const sequence& source);<br/> ~sequence( );<br/> void start( );<br/> void advance( );<br/> void insert(const value_type& entry);<br/> void attach(const value_type& entry);<br/> void operator =(const sequence& source);<br/> void remove_current( );<br/> size_t size( ) const { return many_nodes; }<br/> bool is_item( ) const { return (cursor != nullptr); }<br/> value_type current( ) const;<br/> private:<br/> node *head_ptr;<br/> node *tail_ptr;<br/> node *cursor;<br/> node *precursor;<br/> size_t many_nodes;<br/>};<br/>}<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>// sequence3.cpp<br/>// Linked List Program<br/>// Created by Caden Roberts on 3/9/23.<br/>#include "sequence3.hpp"<br/>#include "assert.h"<br/>using namespace main_savitch_5;<br/>sequence::sequence() {<br/> head_ptr = nullptr;<br/> tail_ptr = nullptr;<br/> cursor = nullptr;<br/> precursor = nullptr;<br/> many_nodes = 0;<br/>}<br/>sequence::sequence(const sequence& source)] {<br/> head_ptr = tail_ptr = cursor = precursor = nullptr;<br/> many_nodes = 0;<br/> node *tail_copy = nullptr;<br/> for (node *p = source.head_ptr; p != nullptr; p = p->link()) {<br/> node *new_node = new node(p->data());<br/> if (tail_copy == nullptr) head_ptr = new_node;<br/> else tail_copy->set_link(new_node);<br/> tail_copy = new_node;<br/> if (p == source.cursor) cursor = new_node;<br/> if (p == source.precursor) precursor = new_node;<br/> ++many_nodes;<br/> }<br/> tail_ptr = tail_copy;<br/>}<br/>sequence::~sequence() {<br/> while (head_ptr != nullptr) {<br/> node* removed_node = head_ptr;<br/> head_ptr = head_ptr->link();<br/> delete removed_node;<br/> }<br/> many_nodes = 0;<br/>}<br/>void sequence::start() {<br/> cursor = head_ptr;<br/> precursor = nullptr;<br/>}<br/>void sequence::advance() {<br/> if (cursor != nullptr) {<br/> precursor=cursor;<br/> cursor=cursor->link();<br/> } else if (head_ptr != nullptr) {<br/> precursor = tail_ptr;<br/> cursor = nullptr;<br/> }<br/>}<br/>void sequence::insert(const value_type& entry) {<br/> if (cursor == nullptr) {<br/> cursor = new node(entry, head_ptr);<br/> if (many_nodes == 0) tail_ptr = cursor;<br/> head_ptr = cursor;<br/> precursor = nullptr;<br/> } else {<br/> cursor = new node(entry, cursor);<br/> if (precursor == nullptr) head_ptr = cursor;<br/> else precursor->set_link(cursor);<br/> }<br/> ++many_nodes;<br/>}<br/>void sequence::attach(const value_type& entry) {<br/> if (cursor==nullptr) {<br/> if (tail_ptr != nullptr) {<br/> tail_ptr->set_link(new node(entry));<br/> precursor = tail_ptr;<br/> cursor = tail_ptr = tail_ptr->link();<br/> } else cursor = tail_ptr = head_ptr = new node(entry);<br/> } else {<br/> precursor = cursor;<br/> cursor->set_link(new node(entry, cursor->link()));<br/> if (cursor == tail_ptr) tail_ptr = cursor->link();<br/> cursor = cursor->link();<br/> }<br/> many_nodes++;<br/>}<br/>void sequence::operator=(const sequence& source) {<br/> if (this == &source) return;<br/> while (head_ptr != nullptr) {<br/> node* removed_node = head_ptr;<br/> head_ptr = head_ptr->link();<br/> delete removed_node;<br/> }<br/> many_nodes = 0;<br/> const node * source_ptr = source.head_ptr;<br/> head_ptr = tail_ptr = nullptr;<br/> if (source_ptr == nullptr) return;<br/> tail_ptr = head_ptr = new node(source_ptr->data( ), head_ptr);<br/> source_ptr = source_ptr->link( );<br/> while (source_ptr != nullptr) {<br/> tail_ptr->set_link(new node(source_ptr->data( ), tail_ptr->link( )));<br/> tail_ptr = tail_ptr->link( );<br/> source_ptr = source_ptr->link( );<br/> }<br/> many_nodes = source.many_nodes;<br/> if (source.cursor == nullptr) {<br/> cursor = nullptr;<br/> precursor = nullptr;<br/> } else {<br/> node* p = head_ptr;<br/> node* source_p = source.head_ptr;<br/> while (source_p != source.cursor) {<br/> p = p->link();<br/> source_p = source_p->link();<br/> }<br/> cursor = p;<br/> precursor = nullptr;<br/> if (p != head_ptr) {<br/> precursor = head_ptr;<br/> while (precursor->link() != p) precursor = precursor->link();<br/> }<br/> }<br/>}<br/>void sequence::remove_current() {<br/> if (cursor == nullptr && precursor == nullptr) return;<br/> if (cursor == head_ptr) {<br/> head_ptr = head_ptr->link();<br/> delete cursor;<br/> cursor = head_ptr;<br/> if (head_ptr == nullptr) tail_ptr = nullptr;<br/> } else {<br/> precursor->set_link(cursor->link());<br/> if (cursor == tail_ptr) tail_ptr = precursor;<br/> delete cursor;<br/> cursor = precursor->link();<br/> }<br/> --many_nodes;<br/>}<br/>value_type sequence::current() const {<br/> assert(is_item());<br/> return cursor->data();<br/>}</code></pre></p> <!-- Dynamic Sequence Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Dynamic Sequence Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (Not included but availible upon request to show code functionality)</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef MAIN_SAVITCH_SEQUENCE_H<br/>#define MAIN_SAVITCH_SEQUENCE_H<br/>#include &#60cstdlib&#62<br/>using namespace std;<br/>namespace main_savitch_4<br/>{<br/>class sequence {<br/> public:<br/> typedef double value_type;<br/> static const size_t DEFAULT_CAPACITY = 30;<br/> sequence(size_t initial_capacity = DEFAULT_CAPACITY);<br/> sequence(const sequence& source);<br/> ~sequence();<br/> void resize(size_t new_capacity);<br/> void start();<br/> void advance();<br/> void insert(const value_type& entry);<br/> void attach(const value_type& entry);<br/> void remove_current();<br/> void operator =(const sequence& source);<br/> size_t size() const;<br/> size_t max_size() const;<br/> bool is_item() const;<br/> value_type current() const;<br/> private:<br/> value_type* data;<br/> size_t used;<br/> size_t current_index;<br/> size_t capacity;<br/>};<br/>}<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>#include &#60iostream&#62<br/>#include "sequence2.h"<br/>#include &#60assert.h&#62<br/>using namespace main_savitch_4;<br/>using namespace std;<br/>sequence::sequence(size_t initial_capacity) {<br/> data = new value_type[initial_capacity];<br/> used = 0;<br/> current_index = 0;<br/> capacity = initial_capacity;<br/>}<br/>sequence::sequence(const sequence& source) {<br/> data = new value_type[source.capacity];<br/> used = source.used;<br/> current_index = source.current_index;<br/> capacity = source.capacity;<br/> for (size_t i = 0; i < used; i++) data[i] = source.data[i];<br/>}<br/>void sequence::resize(size_t new_capacity) {<br/> if (new_capacity <= capacity) return;<br/> value_type* new_data = new value_type[new_capacity];<br/> for (size_t i = 0; i < used; i++) new_data[i] = data[i];<br/> delete[] data;<br/> data = new_data;<br/> capacity = new_capacity;<br/>}<br/>void sequence::start(){ current_index = 0; }<br/>void sequence::advance(){ current_index++; }<br/>void sequence::insert(const value_type& entry) {<br/> if (!is_item()) start();<br/> if (used == capacity) resize(capacity + 1);<br/> for (size_t i = used; i > current_index; i--) data[i] = data[i - 1];<br/> data[current_index] = entry;<br/> used++;<br/>}<br/>void sequence::attach(const value_type& entry) {<br/> if (used == capacity) resize(capacity + 1);<br/> if (is_item()) advance();<br/> else current_index = used;<br/> for (size_t i = used; i > current_index; i--) data[i] = data[i - 1];<br/> data[current_index] = entry;<br/> used++;<br/>}<br/>void sequence::remove_current() {<br/> assert(is_item());<br/> for (size_t i = current_index + 1; i < used+1; i++) data[i - 1] = data[i];<br/> used--;<br/>}<br/>void sequence::operator=(const sequence& source) {<br/> if (this != &source) {<br/> value_type* new_data = new value_type[source.capacity];<br/> for (size_t i = 0; i < source.capacity; i++) new_data[i] = source.data[i];<br/> delete[] data;<br/> data = new_data;<br/> capacity = source.capacity;<br/> used = source.used;<br/> current_index = source.current_index;<br/> }<br/> else return;<br/>}<br/>size_t sequence::size() const { return used; }<br/>size_t sequence::max_size() const { return capacity; }<br/>bool sequence::is_item() const { return (current_index < used); }<br/>sequence::value_type sequence::current() const {<br/> assert(is_item());<br/> return data[current_index];<br/>}<br/>sequence::~sequence() { delete[] data; }</code></pre></p> <!-- Sequence Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Sequence Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (Not included but availible upon request to show code functionality)</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef MAIN_SAVITCH_SEQUENCE_H<br/>#define MAIN_SAVITCH_SEQUENCE_H<br/>#include &#60cstdlib&#62<br/>namespace main_savitch_3<br/>{<br/>class sequence {<br/> public:<br/> typedef double value_type;<br/> typedef std::size_t size_type;<br/> static const size_type CAPACITY = 30;<br/> sequence();<br/> void start();<br/> void advance();<br/> void insert(const value_type& entry);<br/> void attach(const value_type& entry);<br/> void remove_current();<br/> size_type size() const;<br/> bool is_item() const;<br/> value_type current() const;<br/> private:<br/> value_type data[CAPACITY];<br/> size_type used;<br/> size_type current_index;<br/>};<br/>}<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>// Caden Roberts CIST004B 2/16/23<br/>#include "sequence1.h"<br/>#include "assert.h"<br/>using namespace main_savitch_3;<br/>sequence::sequence() {<br/> used = 0;<br/> current_index = 0;<br/>}<br/>void sequence::start() { current_index = 0; }<br/>void sequence::advance() { current_index += 1; }<br/>void sequence::insert(const sequence::value_type& entry) {<br/> assert(size() < CAPACITY);<br/> for (size_type i = used; i > current_index; --i) data[i] = data[i - 1];<br/> data[current_index] = entry;<br/> used++;<br/>}<br/>void sequence::attach(const sequence::value_type& entry) {<br/> assert(size() < CAPACITY);<br/> for (size_type i = used; i > current_index + 1; --i) data[i] = data[i - 1];<br/> if (is_item()) ++current_index;<br/> data[current_index] = entry;<br/> used++;<br/>}<br/>void sequence::remove_current() {<br/> assert(is_item());<br/> for (size_type i = current_index; i < used; i++) data[i] = data[i + 1];<br/> used--;<br/>}<br/>sequence::size_type sequence::size() const { return used; }<br/>bool sequence::is_item() const { return (current_index < used); }<br/>sequence::value_type sequence::current() const { return data[current_index]; }</code></pre></p> <!-- Statistician Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Statistician Program</h3> <p> An exam file will generate an output of test results for all functions and operators of the class. (Not included but availible upon request to show code functionality)</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#pragma once<br/>#ifndef STATS_H<br/>#define STATS_H<br/>#include &#60iostream&#62<br/>namespace main_savitch_2C<br/>{<br/>class statistician {<br/> public:<br/> statistician();<br/> void next(double r);<br/> void reset();<br/> int length() const;<br/> double sum() const;<br/> double mean() const;<br/> double minimum() const;<br/> double maximum() const;<br/> friend statistician operator + (const statistician& s1, const statistician& s2);<br/> friend statistician operator * (double scale, const statistician& s);<br/> private:<br/> int count = 0;<br/> double total = 0;<br/> double tinyest = 0;<br/> double largest = 0;<br/>};<br/>bool operator ==(const statistician& s1, const statistician& s2);<br/>}<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>// Caden Roberts 2/12/23 CIST004B<br/>#include "stats.h"<br/>#include "assert.h"<br/>using namespace std;<br/>using namespace main_savitch_2C;<br/>statistician::statistician() {<br/> count = 0;<br/> total = 0;<br/> largest = 0;<br/> tinyest = 0;<br/>}<br/>void statistician::next(double r) {<br/> if (count == 0) {<br/> tinyest = r;<br/> largest = r;<br/> }<br/> count += 1;<br/> total += r;<br/> tinyest = tinyest < r ? tinyest : r;<br/> largest = largest > r ? largest : r;<br/>}<br/>void statistician::reset() {<br/> statistician s;<br/> *this = s;<br/>}<br/>int statistician::length() const { return count; }<br/>double statistician::sum() const { return total; }<br/>double statistician::mean() const {<br/> assert(count > 0);<br/> return total / (static_cast&#60double&#62(count));<br/>}<br/>double statistician::minimum() const {<br/> assert(count>0);<br/> return tinyest;<br/>}<br/>double statistician::maximum() const {<br/> assert(count > 0);<br/> return largest;<br/>}<br/>statistician main_savitch_2C::operator + (const statistician& s1, const statistician& s2) {<br/> if (s1.length() == 0) return s2;<br/> if (s2.length() == 0) return s1;<br/> statistician s;<br/> for (double i = static_cast&#60double&#62(s1.length() + s2.length() - 2), a = (static_cast&#60double&#62(s1.sum() + s2.sum() - min(s1.minimum(), s2.minimum()) - max(s1.maximum(), s2.maximum())) / i); i > 0; i--) s.next(a);<br/> s.next(min(s1.minimum(), s2.minimum()));<br/> s.next(max(s1.maximum(), s2.maximum()));<br/> return s;<br/>}<br/>statistician main_savitch_2C::operator * (double scale, const statistician& s) {<br/> if (s.length() == 0) return s;<br/> statistician s1;<br/> for (int i = s.length() - 2, a = (s.sum() * scale - s.minimum() * scale - s.maximum() * scale) / i; i > 0; i--) s1.next(a);<br/> s1.next(s.minimum() * scale);<br/> s1.next(s.maximum() * scale);<br/> return s1;<br/>}<br/>bool main_savitch_2C::operator == (const statistician& s1, const statistician& s2) {<br/> if ((s1.length() > 0) && (s2.length() > 0)) return ((s1.minimum() == s2.minimum()) && (s1.maximum() == s2.maximum()) && (s1.length() == s2.length()) && (s1.mean() == s2.mean()) && (s1.sum() == s2.sum()));<br/> else if ((s1.length() == 0) && (s2.length() == 0)) return true;<br/> else return false;<br/>}</code></pre></p> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#include "Deck.h"<br/>#include "Card.h"<br/>#include &#60vector&#62<br/>Deck::Deck() {<br/> for (size_t cardSuit = 0; cardSuit < 4; ++cardSuit) for (size_t cardFace = 0; cardFace < 13; ++cardFace) Deck::theDeckOfCards.emplace_back(Card{ cardSuit, cardFace });<br/> indexOfNextCard = 0;<br/>}<br/><br/>void Deck::shuffleTheDeck() {<br/> for (size_t shuffleCount = 0; shuffleCount < 250; shuffleCount++) {<br/> size_t x = rand() % 52;<br/> size_t y = rand() % 52;<br/> Card temp(0, 0);<br/> temp = theDeckOfCards[x];<br/> theDeckOfCards[x] = theDeckOfCards[y];<br/> theDeckOfCards[y] = temp;<br/> }<br/> indexOfNextCard = 0;<br/>}<br/>Card Deck::dealOneCard() {<br/> return theDeckOfCards[indexOfNextCard++];<br/>}<br/><br/>bool Deck::cardsLeft() {<br/> return (51 >= indexOfNextCard);<br/>}</code></pre></p> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include "Card.h"<br/>#include "Deck.h"<br/>int main() {<br/> int i{ 1 };<br/> std::cout << "Caden Roberts\t10/29/22\tCIST004A\n";<br/> Deck theDeckOfCards;<br/> do {<br/> std::cout << '\n';<br/> for (int j = i; j > 0; j--) theDeckOfCards.shuffleTheDeck();<br/> int counter{ 1 };<br/> while (theDeckOfCards.cardsLeft()) {<br/> std::cout << std::left << std::setw(20) << (theDeckOfCards.dealOneCard()).cardToString();<br/> if (counter++ % 4 == 0) std::cout << '\n';<br/> }<br/> std::cout << "\nEnter # of times to shuffle again, or enter any non-integer key to exit : ";<br/> std::cin >> i;<br/> } while (!std::cin.fail());<br/> return 0;<br/>}</code></pre></p> <!-- MinMaxMeanMedianMode Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Min Max Mean Median Mode Program</h3><p>For ouput, a list size and numbers within the list are inquired about, and then the calculations on said list are performed.</p></blockquote> <p><pre><code>#include &#60iostream&#62<br/>#include &#60vector&#62<br/>#include &#60algorithm&#62<br/>#include &#60numeric&#62<br/><br/>void MinMaxMeanMedianMode(std::vector<int> list) {<br/> std::sort(list.begin(), list.end());<br/> std::cout << "\nThe list of numbers has the following characteristics:\nThe Minimum is : " << list[0] << "\nThe Maximum is: " << list[list.size() - 1] << "\nThe Mean is: " << static_cast&#60float&#62(std::accumulate(list.rbegin(), list.rend(), 0)) / static_cast&#60float&#62(list.size()) << "\nThe Median is: ";<br/> if (list.size() % 2 == 0) std::cout << (list[list.size() / 2] + list[list.size() / 2 - 1]) / 2;<br/> else std::cout << list[(list.size() - 1) / 2];<br/> std::vector&#60int&#62 numfreq(list[list.size()-1]+1, 0);<br/> int modefreq{0};<br/> for (auto a : list) {<br/> numfreq[a] += 1;<br/> modefreq = modefreq > numfreq[a] ? modefreq : numfreq[a];<br/> }<br/> std::vector&#60int&#62 modes;<br/> for (int i = 0; i < numfreq.size(); i++) if (numfreq[i] == modefreq) modes.insert(modes.end(), i);<br/> if (modes.size() == 1) std::cout << "\nThe Mode is: " << modes[0];<br/> else {<br/> std::cout << "\nThe list is multimodal, and contains " << modes.size() << " modes. The modes are: ";<br/> for (auto a : modes) {<br/> if (a == modes[modes.size() - 2]) std::cout << a << " and ";<br/> else if (a == modes[modes.size() - 1]) std::cout << a << ".";<br/> else std::cout << a << ", ";<br/> }<br/> }<br/>}<br/>std::vector&#60int&#62 InquireUserList() {<br/> int number;<br/> std::vector&#60int&#62 list;<br/> do {<br/> std::cout << "How many numbers are in your list (1 to 100)?: ";<br/> std::cin >> number;<br/> if (number < 1) std::cout << "Hey come on! The list must have at least 1 number!\n";<br/> else if (number > 100) std::cout << "Really! You are prepared to enter 101 numbers? I don't think so!\n";<br/> } while (number < 1 || number>100);<br/> list.resize(number);<br/> std::cout << "\nYour list may have numbers between 1 and 1000.\n\n";<br/> for (int i = 1; i <= list.size(); i++) {<br/> do {<br/> if (i%100 >= 11 && i%100 <= 19) std::cout << "Enter the " << i << "th number: ";<br/> else switch (i % 10) {<br/> case 1:<br/> std::cout << "Enter the " << i << "st number: ";<br/> break;<br/> case 2:<br/> std::cout << "Enter the " << i << "nd number: ";<br/> break;<br/> case 3:<br/> std::cout << "Enter the " << i << "rd number: ";<br/> break;<br/> default:<br/> std::cout << "Enter the " << i << "th number: ";<br/> }<br/> std::cin >> number;<br/> if (number < 1 || number > 1000) std::cout << "Please enter a valid number between 1 and 1000!\n";<br/> } while (number < 1 || number > 1000);<br/> list[i - 1] = number;<br/> }<br/> return list;<br/>}<br/><br/>int main() {<br/> std::cout << "Caden W Roberts\t\t\t\tCIST004B 1/31/23\nMinimum, Maximum, Mean, Median and Mode Calculator with extra polish and multimodal support.\n";<br/> MinMaxMeanMedianMode(InquireUserList());<br/> return 0;<br/>}</code></pre></p> </div> </div> <!-- CSV Health Record File Creation Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">CSV Health Record File Creation Program</h3> <p> Output is a CSV file table of name, height, weight, and BMI.</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#pragma once<br/>#ifndef HealthRecord_h<br/>#define HealthRecord_h<br/>#include &#60string&#62<br/>#include &#60fstream&#62<br/>class HealthRecord {<br/> public:<br/> HealthRecord(std::string personName = "", int personHeight = 1, int personWeight = 0);<br/> ~HealthRecord() {}<br/> void setName(std::string personName);<br/> std::string getName();<br/> void setHeight(int personHeight);<br/> int getHeight();<br/> void setWeight(int personWeight);<br/> int getWeight();<br/> float computeBMI();<br/> void outputCSV(std::ofstream& outFile);<br/> void inputCSV(std::string theFileName); <br/> private:<br/> std::string name;<br/> int height;<br/> int weight;<br/>};<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>#include &#60iostream&#62<br/>#include &#60string&#62<br/>#include &#60fstream&#62<br/>#include &#60iomanip&#62<br/>#include "HealthRecord.h"<br/>HealthRecord::HealthRecord(std::string personName, int personHeight, int personWeight) { <br/>name = personName; <br/>height = personHeight; <br/>weight = personWeight;<br/>}<br/>void HealthRecord::setName(std::string personName) { name = personName; }<br/>std::string HealthRecord::getName() { return name; }<br/>void HealthRecord::setHeight(int personHeight) { height = personHeight; }<br/>int HealthRecord::getHeight() { return height; }<br/>void HealthRecord::setWeight(int personWeight) { weight = personWeight; }<br/>int HealthRecord::getWeight() { return weight; }<br/>float HealthRecord::computeBMI() { return static_cast&#60float&#62(weight) / (2.20462f * ((static_cast&#60float&#62(height) * 0.0254f) * (static_cast&#60float&#62(height) * 0.0254f))); }<br/>void HealthRecord::outputCSV(std::ofstream& outputFile) { outputFile << std::fixed << std::setprecision(2) << getName() << ',' << getHeight() << ',' << getWeight() << ',' << computeBMI() << '\r' << '\n'; } <br/>void HealthRecord::inputCSV(std::string theFileName) {<br/> std::ifstream inputFile{ theFileName, std::ios::in }; <br/> char c;<br/> while (!inputFile.eof()) {<br/> inputFile.get(c);<br/> std::cout << c; <br/> } <br/> inputFile.close();<br/>}</code></pre></p> <p><pre><code>#include &#60iostream&#62<br/>#include &#60fstream&#62<br/>#include &#60vector&#62<br/>#include &#60iomanip&#62<br/>#include "HealthRecord.h"<br/>std::ofstream myOutFile;<br/>std::ifstream myInFile;<br/>std::fstream myWRfile;<br/>std::streampos begin, end;<br/>bool getHealthInfo(HealthRecord* record) {<br/> bool x = (!(record->getName() == "") && !(record->getHeight() == 1) && ! (record->getWeight() == 0));<br/> if (!x) std::cout << "Record will not be created.\n";<br/> return x;<br/>}<br/>std::streampos getFileLength(std::string theFileName) {<br/> std::ifstream file(theFileName, std::ios::binary | std::ios::in);<br/> begin = file.tellg();<br/> file.seekg(0, std::ios::end);<br/> end = file.tellg();<br/> file.close();<br/> return (end - begin);<br/>}<br/>int main() {<br/> std::cout << "Caden Roberts\t\t12/5/22\t\tCIST004A\n";<br/> std::vector &#60HealthRecord*&#62 Vector;<br/> int i = 0, personWeight = 0, personHeight = 1;<br/> std::string personName, fileName;<br/> char C = 'Y';<br/> do {<br/> Vector.resize(++i);<br/> std::cout << "\nEnter Heath Record Data. Hit <return> on any blank line to end.\nHealth Record #" << i << "\nEnter the name(enter return when done): ";<br/> std::getline(std::cin, personName);<br/> if (personName != "") {<br/> std::cout << "Enter " << personName << "'s height in inches: ";<br/> std::cin >> personHeight;<br/> std::cin.ignore(1000, '\n');<br/> std::cout << "Enter " << personName << "'s weight in pounds: ";<br/> std::cin >> personWeight;<br/> std::cin.ignore(1000, '\n');<br/> }<br/> Vector[static_cast&#60std::vector&#60HealthRecord*, std::allocator&#60HealthRecord*&#62&#62::size_type&#62(i) - 1] = new HealthRecord(personName, personHeight, personWeight);<br/> if (!getHealthInfo(Vector[static_cast&#60std::vector&#60HealthRecord*, std::allocator&#60HealthRecord*&#62&#62::size_type&#62(i) - 1])) {<br/> Vector.pop_back(); <br/> break;<br/> }<br/> } while (1);<br/> do {<br/> std::cout << "\nEnter a new file name to create: ";<br/> std::getline(std::cin, fileName);<br/> if (std::fstream(fileName)) {<br/> C = 'z';<br/> std::cout << "File name " << fileName << " already exists.\n";<br/> do {<br/> std::cout << "Would you like to overwrite the file named \"" << fileName << "\"? (Y / N) :";<br/> std::cin >> C;<br/> std::cin.ignore(1000, '\n');<br/> } while (toupper(C) != 'Y' && toupper(C) != 'N');<br/> }<br/> if (toupper(C) == 'Y') {<br/> std::ofstream file(fileName);<br/> if (file) {<br/> std::cout << "The file \"" << fileName << "\" was successfully created.\n";<br/> for (int r = 0; r < i - 1; r++) Vector[r]->outputCSV(file);<br/> std::cout << "The file was written.\n";<br/> break;<br/> } else std::cout << "The file \"" << fileName << "\" could not be created.\n";<br/> }<br/> } while (1);<br/> std::cout << "The file \"" << fileName << "\" is " << getFileLength(fileName) << " bytes long.\n\nEnter the final Health Record:\nEnter the name: ";<br/> std::getline(std::cin, personName);<br/> if (personName != "") {<br/> std::cout << "Enter " << personName << "'s height in inches: ";<br/> std::cin >> personHeight;<br/> std::cin.ignore(1000, '\n');<br/> std::cout << "Enter " << personName << "'s weight in pounds: ";<br/> std::cin >> personWeight;<br/> std::cin.ignore(1000, '\n');<br/> }<br/> std::ofstream file(fileName, std::ios::app);<br/> if (getHealthInfo(new HealthRecord(personName, personHeight, personWeight))) HealthRecord(personName, personHeight, personWeight).outputCSV(file);<br/> file.close();<br/> std::cout << "The file \"" << fileName << "\" is now " << getFileLength(fileName) << " bytes long.\n\nNow reading finalized file:\n";<br/> std::ifstream File(fileName);<br/> Vector[0]->inputCSV(fileName);<br/> return 0;<br/>}</code></pre></p> <!-- Polymorphic Bank Account Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Polymorphic Bank Account Program</h3> <p> Output is a test of various functions (Deposit, Withdraw, etc.) called on the base and polymorphic classes. </p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef BaseAccount_h<br/>#define BaseAccount_h<br/>#pragma once<br/>#include &#60string&#62<br/>class BaseAccount {<br/> public:<br/> BaseAccount(double initialBalance);<br/> ~BaseAccount() {};<br/> double getBalance();<br/> virtual void credit(double amount);<br/> virtual bool debit(double amount);<br/> void setOwner(std::string owner);<br/> std::string getOwner();<br/> private:<br/> long int balanceInPennies = 0L;<br/> std::string ownerName = "There is currently no name registered to the account.";<br/>};<br/><br/>#endif</p></pre></code> <p><pre><code>#ifndef CheckingAccount_h<br/>#define CheckingAccount_h<br/>#pragma once<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/><br/>class CheckingAccount : public BaseAccount {<br/> public:<br/> CheckingAccount(double initialBalance, double initialFee);<br/> ~CheckingAccount() {};<br/> virtual void credit(double amount);<br/> virtual bool debit(double amount);<br/> protected:<br/> double checkingFee = 0;<br/>};<br/><br/>#endif</code></pre></p> <p><pre><code>#ifndef SavingsAccount_h<br/>#define SavingsAccount_h<br/>#pragma once<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/><br/>class SavingsAccount : public BaseAccount {<br/> public:<br/> SavingsAccount(double initialBalance, double initialRate);<br/> ~SavingsAccount() {};<br/> double computeInterest();<br/> private:<br/> double interestRate = 0;<br/>};<br/><br/>#endif</code></pre></p> <p><pre><code>#ifndef OverdraftCheckingAccount_h<br/>#define OverdraftCheckingAccount_h<br/>#pragma once<br/>#include &#60string&#62<br/>#include "SavingsAccount.h"<br/>#include "CheckingAccount.h"<br/>class OverdraftCheckingAccount : public CheckingAccount {<br/> public:<br/> OverdraftCheckingAccount(double intialBalance, double initialFee, double overdraft, SavingsAccount* Ptr);<br/> ~OverdraftCheckingAccount() {};<br/> bool debit(double amount);<br/> private:<br/> double overdraftFee;<br/> SavingsAccount* link;<br/>};<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>#include "BaseAccount.h"<br/>#include &#60string&#62<br/>#include &#60iostream&#62<br/>BaseAccount::BaseAccount(double initialBalance) {<br/> if ((balanceInPennies = lround(initialBalance * 100.0)) < 0L) {<br/> std::cout << "Failed Account Creation (Low Fund Entry)\n";<br/> balanceInPennies = 0L;<br/> }<br/>}<br/>double BaseAccount::getBalance() { return static_cast &#60double&#62 (balanceInPennies) / 100.0; }<br/>void BaseAccount::credit(double amount) {<br/> if (lround(amount * 100.0) >= 0) balanceInPennies += lround(amount * 100.0);<br/> else std::cout << "Insufficient amount to warrant a deposit.\n";<br/>}<br/>bool BaseAccount::debit(double amount) {<br/> if (balanceInPennies >= lround(amount * 100.0)) balanceInPennies -= lround(amount * 100.0);<br/> else std::cout << "Insufficient funds to withdraw from this account.\n";<br/> return balanceInPennies >= lround(amount * 100.0);<br/>}<br/>void BaseAccount::setOwner(std::string owner) { ownerName = owner; }<br/>std::string BaseAccount::getOwner() { return ownerName;} </code></pre></p> <p><pre><code>#include "CheckingAccount.h"<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include &#60iostream&#62<br/>CheckingAccount::CheckingAccount(double initialBalance, double initialFee) : BaseAccount::BaseAccount(initialBalance) { checkingFee = initialFee; }<br/>void CheckingAccount::credit(double amount) {<br/> BaseAccount::credit(amount - checkingFee);<br/> if (amount > checkingFee) std::cout << "Checking Fee of $" << checkingFee << " charged.\n";<br/>}<br/>bool CheckingAccount::debit(double amount) {<br/> bool x = (BaseAccount::debit(amount + checkingFee));<br/> if (x) std::cout << "Checking Fee of $" << checkingFee << " charged.\n";<br/> return x;<br/>} </code></pre></p> <p><pre><code>#include "SavingsAccount.h"<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include &#60iostream&#62<br/>SavingsAccount::SavingsAccount(double initialBalance, double initialRate) : BaseAccount::BaseAccount(initialBalance) { interestRate = initialRate; }<br/>double SavingsAccount::computeInterest() { return ((interestRate / 100.0) * getBalance()); } </code></pre></p> <p><pre><code>#include "CheckingAccount.h"<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include "SavingsAccount.h"<br/>#include "OverdraftCheckingAccount.h"<br/>OverdraftCheckingAccount::OverdraftCheckingAccount(double initialBalance, double initialFee, double overdraft, SavingsAccount* Ptr) : CheckingAccount::CheckingAccount(initialBalance, initialFee) {<br/> overdraftFee = overdraft;<br/> link = Ptr;<br/>}<br/>bool OverdraftCheckingAccount::debit(double amount) {<br/> if (CheckingAccount::debit(amount)) return true;<br/> else if (link->BaseAccount::debit(amount + checkingFee + overdraftFee - getBalance())) {<br/> BaseAccount::debit(getBalance());<br/> std::cout << "$" << overdraftFee << " overdraft fee charged and $" << checkingFee << " checking fee charged. $" << link->getBalance() << " remaining in Savings Account.\n";<br/> return true;<br/> }<br/> else return false;<br/>} </code></pre></p> <p><pre><code>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include "CheckingAccount.h"<br/>#include "SavingsAccount.h"<br/>#include "OverdraftCheckingAccount.h"<br/>#include &#60vector&#62<br/><br/>int main() {<br/> std::cout << "Caden Roberts\t\t11/17/22\t\tCIST004A\n";<br/> std::vector &#60BaseAccount*&#62 Vector(4);<br/> Vector[0] = new SavingsAccount(25.00, 3.00);<br/> Vector[1] = new CheckingAccount(80.00, 2.00);<br/> Vector[2] = new SavingsAccount(200.00, 1.50);<br/> Vector[3] = new OverdraftCheckingAccount(400.00, 1.50, 35.00, dynamic_cast&#60SavingsAccount*&#62(Vector[2]));<br/> double input = -1;<br/> for (int i = 0; i < 4; i++) {<br/> std::cout << "\nAccount " << i + 1 << " balance: $" << std::fixed << std::setprecision(2) << Vector[i]->getBalance() << "\n";<br/> int a = 0;<br/> do {<br/> if (a > 0) { <br/> std::cin.clear();<br/> std::cin.ignore(1000, '\n');<br/> std::cout << "Error. Please enter a positive number.\n"; <br/> }<br/> std::cout << "Enter an amount to withdraw from Account " << i + 1 << ": ";<br/> std::cin >> input;<br/> } while ((std::cin.peek() != '\n') || (input < 0) || (std::cin.fail()));<br/> Vector[i]->debit(input);<br/> a = 0;<br/> do {<br/> if (a > 0) { <br/> std::cin.clear();<br/> std::cin.ignore(1000, '\n');<br/> std::cout << "Error. Please enter a positive number.\n"; <br/> }<br/> std::cout << "Enter an amount to deposit to Account " << i + 1 << ": ";<br/> std::cin >> input;\<br/> } while ((std::cin.peek() != '\n') || (input < 0) || (std::cin.fail()));\<br/> Vector[i]->credit(input);\<br/> if (dynamic_cast &#60SavingsAccount*&#62 (Vector[i]) != nullptr) {<br/> std::cout << "Adding $" << dynamic_cast<SavingsAccount*>(Vector[i])->computeInterest() << " to Account " << i + 1 << " (Savings Account)\n";<br/> Vector[i]->credit(dynamic_cast&#60SavingsAccount*&#62(Vector[i])->computeInterest());<br/> }<br/> std::cout << "Updated Account " << i + 1 << " balance: $" << Vector[i]->getBalance() << "\n";<br/> }<br/> return 0;<br/>}</code></pre></p> <!-- Bank Account Inheritance Heirarchy Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Bank Account Inheritance Heirarchy Program</h3> <p> Output is a test of various functions (Deposit, Withdraw, etc.) called on the base and inheritance classes. </p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>#ifndef BaseAccount_h<br/>#define BaseAccount_h<br/>#pragma once<br/>#include &#60string&#62<br/><br/>class BaseAccount { <br/> public: <br/> BaseAccount(double initialBalance); <br/> ~BaseAccount() {}; <br/> double getBalance(); <br/> void deposit(double amount); <br/> bool withdraw(double amount); <br/> void setOwner(std::string owner);<br/> std::string getOwner();<br/> private:<br/> long int balanceInPennies = 0L;<br/> std::string ownerName = "There is currently no name registered to the account.";<br/>};<br/><br/>#endif</p></pre></code> <p><pre><code>#ifndef CheckingAccount_h<br/>#define CheckingAccount_h<br/>#pragma once<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/><br/>class CheckingAccount : public BaseAccount {<br/> public:<br/> CheckingAccount(double initialBalance, double initialFee);<br/> ~CheckingAccount() {};<br/> void deposit(double amount);<br/> bool withdraw(double amount);<br/> private:<br/> double checkingFee = 0;<br/>};<br/><br/>#endif</p></pre></code> <p><pre><code>#include "SavingsAccount.h"<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include &#60iostream&#62<br/>SavingsAccount::SavingsAccount(double initialBalance, double initialRate) : BaseAccount::BaseAccount(initialBalance) { interestRate = initialRate; }<br/>double SavingsAccount::computeInterest() { return ((interestRate / 100.0) * BaseAccount::getBalance()); }</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>#include "BaseAccount.h"<br/>#include &#60string&#62<br/>#include &#60iostream&#62<br/>BaseAccount::BaseAccount(double initialBalance) {<br/> if ((balanceInPennies == lround(initialBalance * 100.0)) < 0L) {<br/> std::cout << "Failed Account Creation (Low Fund Entry)\n";<br/> balanceInPennies = 0L;<br/> }<br/>}<br/>double BaseAccount::getBalance() { return static_cast &#60double&#62 (balanceInPennies) / 100.0; }<br/>void BaseAccount::deposit(double amount) {<br/> if (amount > 0) balanceInPennies += lround(amount * 100.0);<br/> else std::cout << "Deposit failed; amount must be positive, dollars and pennies.\n";<br/>}<br/>bool BaseAccount::withdraw(double amount) {<br/> if (static_cast &#60double&#62 (balanceInPennies) / 100.0 > amount) balanceInPennies -= lround(amount * 100.0);<br/> else std::cout << "Insufficient funds to honor the withdrawal request.\n";<br/> return static_cast &#60double&#62 (balanceInPennies) / 100.0 > amount;<br/>}<br/>void BaseAccount::setOwner(std::string owner) { ownerName = owner; }<br/>std::string BaseAccount::getOwner() { return ownerName; }</code></pre></p> <p><pre><code>#include "CheckingAccount.h"<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include &#60iostream&#62<br/>CheckingAccount::CheckingAccount(double initialBalance, double initialFee) : BaseAccount::BaseAccount(initialBalance) { checkingFee = initialFee; }<br/>void CheckingAccount::deposit(double amount) {<br/> BaseAccount::deposit(amount - checkingFee);<br/> std::cout << "$" << checkingFee << " checking account transaction fee charged.\n";<br/>}<br/>bool CheckingAccount::withdraw(double amount) {<br/> if (amount + checkingFee < getBalance()) std::cout << "$" << checkingFee << "checking transaction fee charged.\n";<br/> return (BaseAccount::withdraw(amount + checkingFee));<br/>}</code></pre></p> <p><pre><code>#include "SavingsAccount.h"<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include &#60iostream&#62<br/>SavingsAccount::SavingsAccount(double initialBalance, double initialRate) : BaseAccount::BaseAccount(initialBalance) { interestRate = initialRate; }<br/>double SavingsAccount::computeInterest() { return ((interestRate / 100.0) * BaseAccount::getBalance()); }</code></pre></p> <p><pre><code>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include &#60string&#62<br/>#include "BaseAccount.h"<br/>#include "CheckingAccount.h"<br/>#include "SavingsAccount.h"<br/><br/>int main() {<br/> std::cout << "Caden Roberts\t\t11/17/22\t\tCIST004A\nCreating 3 Test Bank Accounts:\n";<br/> BaseAccount Account1{ 50.01 };<br/> SavingsAccount Account2{ 25.02, 5.00 };<br/> CheckingAccount Account3{ 80.03, 1.00 };<br/> std::cout << "Account 1 (Base) balance: $" << std::fixed << std::setprecision(2) << Account1.getBalance() << "\nAccount 2 (Savings) balance: $" << Account2.getBalance() << "\nAccount 3 (Checking) balance: $" << Account3.getBalance() << "\n\nBank Account Withdrawal Tests: \nNow withdrawing $25.00 from account 1.\n";<br/> Account1.withdraw(25.00);<br/> std::cout << "Now withdrawing $30.00 from account 2.\n";<br/> Account2.withdraw(30.00);<br/> std::cout << "Now withdrawing $40.00 from account 3.\n";<br/> Account3.withdraw(40.00);<br/> std::cout << "\nAccount 1 balance: $" << Account1.getBalance() << "\nAccount 2 balance: $" << Account2.getBalance() << "\nAccount 3 balance: $" << Account3.getBalance() << "\n\nBank Account Deposit Tests: \nNow depositing $40.23 to account 1.\n";<br/> Account1.deposit(40.23);<br/> std::cout << "Now depositing $65.99 to account 2.\n";<br/> Account2.deposit(65.99);<br/> std::cout << "Now depositing $20.01 to account 3.\n";<br/> Account3.deposit(20.01);<br/> std::cout << "\nAccount 1 balance: $" << Account1.getBalance() << "\nAccount 2 balance: $" << Account2.getBalance() << "\nAccount 3 balance: $" << Account3.getBalance() << "\n\nBank Account Interest Test: \nAdding $" << Account2.computeInterest() << " interest to account 2.\n";<br/> Account2.deposit(Account2.computeInterest());<br/> std::cout << "The new account 2 balance is: $" << Account2.getBalance() << "\n\n";<br/> std::cout << "Bank Account Name Tests: \nAccount 1 name: " << Account1.getOwner() << "\nAccount 2 name: " << Account2.getOwner() << "\nAccount 3 name: " << Account3.getOwner() << "\n\nNow naming account 1 to James Black.\n";<br/> Account1.setOwner("James Black");<br/> std::cout << "Now naming account 2 to Christie Johnson.\n";<br/> Account2.setOwner("Christie Johnson");<br/> std::cout << "Now naming account 3 to Kris Deen.\n\n";<br/> Account3.setOwner("Kris Deen");<br/> std::cout << "New account 1 name: " << Account1.getOwner() << "\nNew account 2 name: " << Account2.getOwner() << "\nNew account 3 name: " << Account3.getOwner() << "\n\n";<br/> return 0;<br/>}</code></pre></p> <!-- Card Game Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Card Game Program</h3> <p> Output is a score table you vs. the Computer. You both draw cards at random in a War-Style game until someone has 2 more wins than an opponent. </p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#ifndef Card_h<br/>#define Card_h<br/>#pragma once<br/>#include &#60string&#62<br/><br/>class Card {<br/> public:<br/> Card(size_t cardSuit, size_t cardFace);<br/> std::string cardToString() const;<br/> bool operator > (const Card&);<br/> bool operator < (const Card&);<br/> bool operator == (const Card&);<br/> private:<br/> int refCount;<br/> size_t face;<br/> size_t suit;<br/> static const std::string faceNames[13];<br/> static const std::string suitNames[4];<br/>};<br/><br/>#endif</code></pre></p> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#ifndef Deck_h<br/>#define Deck_h<br/>#pragma once<br/>#include "Card.h"<br/>#include &#60vector&#62<br/><br/>class DeckOfCards {<br/> public:<br/> DeckOfCards();<br/> void shuffleTheDeck();<br/> Card* dealOneCard();<br/> Card* getCard(size_t);<br/> bool cardsLeft() const;<br/> private:<br/> std::vector < Card* > deck;<br/> size_t indexOfNextCard;<br/>};<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#include "Card.h"<br/>#include &#60string&#62<br/>const std::string Card::faceNames[] = { "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace" };<br/>const std::string Card::suitNames[] = { "Clubs", "Diamonds", "Hearts", "Spades" };<br/>Card::Card(size_t cardSuit, size_t cardFace) {<br/> refCount = 1;<br/> suit = cardSuit;<br/> face = cardFace;<br/>}<br/>std::string Card::cardToString() const {<br/> return faceNames[face] + " of " + suitNames[suit];<br/>}<br/>bool Card::operator > (const Card& param) { return ((face > param.face) || ((face == param.face) && (suit > param.suit))); }<br/>bool Card::operator < (const Card& param) { return ((face < param.face) || ((face == param.face) && (suit < param.suit))); }<br/>bool Card::operator == (const Card& param) { return ((face == param.face) && (suit == param.suit)); }</code></pre></p> <p><pre><code>#include "Deck.h"<br/>#include "Card.h"<br/>#include &#60vector&#62<br/>DeckOfCards::DeckOfCards() {<br/> for (size_t cardSuit = 0; cardSuit < 4; ++cardSuit) for (size_t cardFace = 0; cardFace < 13; ++cardFace) DeckOfCards::deck.emplace_back(new Card(cardSuit, cardFace));<br/> indexOfNextCard = 0;<br/>}<br/>void DeckOfCards::shuffleTheDeck() {<br/> for (size_t shuffleCount = 0; shuffleCount < 250; shuffleCount++) {<br/> size_t x = rand() % 52;<br/> size_t y = rand() % 52;<br/> Card* temp = (nullptr);<br/> temp = deck[x];<br/> deck[x] = deck[y];<br/> deck[y] = temp;<br/> }<br/> indexOfNextCard = 0;<br/>}<br/>Card* DeckOfCards::dealOneCard() { return deck[rand() % 52]; }<br/>Card* DeckOfCards::getCard(size_t input) { return deck[input]; }<br/>bool DeckOfCards::cardsLeft() const { return (51 >= indexOfNextCard); }</code></pre></p> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include "Card.h"<br/>#include "Deck.h"<br/>int main() {<br/> size_t input;<br/> size_t cinput;<br/> int Comp{ 0 };<br/> int You{ 0 };<br/> std::string x;<br/> std::cout << "Caden Roberts\t\t\t11/7/22\t\t\t\tCIST004A";<br/> DeckOfCards deck;<br/> do {<br/> std::cout << "\n\n* * * * * * * * *\t\tCurrent Score\t\t* * * * * * * * *\n" << "|||\tYou\t:\t" << You << "\t\t|||\tComputer\t:\t" << Comp;<br/> deck.shuffleTheDeck();<br/> do {<br/> std::cout << "\n\nPlease Enter a card number from 0 to 51: ";<br/> std::cin >> input;<br/> if ((std::cin.fail()) or (std::cin.peek() != '\n')) input = 52;<br/> std::cin.clear(); std::cin.ignore(1000, '\n');<br/> } while ((input > 51) or (input < 0));<br/> cinput = rand() % 52;<br/> std::cout << "\nYour selected card is: " << (*(deck.getCard(input))).cardToString() << ".";<br/> std::cout << "\nThe Computer's card is: " << (*(deck.getCard(cinput))).cardToString() << ".";<br/> if ((*(deck.getCard(cinput))) > (*(deck.getCard(input)))) { x = "lose"; Comp++; }<br/> else if ((*(deck.getCard(cinput))) < (*(deck.getCard(input)))) { x = "win"; You++; }<br/> else x = "tied";<br/> std::cout << "\nYou " + x + " this round!";<br/> } while ((Comp - You) < 2 and (You - Comp) < 2);<br/> std::cout << "\nAnd you " + x + " the game!\n\nFINAL\t\tSCORE\t\tYou - " << You << "\t:\tComp - " << Comp << std::endl;<br/> return 0;<br/>}</code></pre></p> <!-- Deck of Cards Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Deck of Cards Program</h3> <p> Output is a fully shuffled deck of cards, shuffleable any number of times before displaying the new deck.</p></blockquote> <h3 class = "major">Header Files</h3> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#ifndef Card_h<br/>#define Card_h<br/>#pragma once<br/>#include &#60string&#62<br/><br/>class Card {<br/> private:<br/> size_t face, suit;<br/> static const std::string namesOfFaces[], namesOfSuits[];<br/> public:<br/> Card(size_t cardSuit, size_t cardFace);<br/> ~Card() {};<br/> size_t getSuitValue(), getFaceValue();<br/> std::string cardToString();<br/>};<br/><br/>#endif</code></pre></p> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#ifndef Deck_h<br/>#define Deck_h<br/>#pragma once<br/>#include "Card.h"<br/>#include &#60vector&#62<br/><br/>class Deck {<br/> private:<br/> std::vector < Card > theDeckOfCards;<br/> size_t indexOfNextCard;<br/> public:<br/> Deck();<br/> ~Deck() {};<br/> void shuffleTheDeck();<br/> Card dealOneCard();<br/> bool cardsLeft();<br/>};<br/><br/>#endif</code></pre></p> <h3 class = "major">CPP Files</h3> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#include "Card.h"<br/>#include &#60string&#62<br/>const std::string Card::namesOfFaces[] = {"Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace"};<br/>const std::string Card::namesOfSuits[] = { "Hearts", "Clubs", "Diamonds", "Spades" };<br/>Card::Card(size_t cardSuit, size_t cardFace) {<br/> suit = cardSuit;<br/> face = cardFace;<br/>}<br/>size_t Card::getSuitValue() {<br/> return suit;<br/>}<br/>size_t Card::getFaceValue() {<br/> return face;<br/>}<br/>std::string Card::cardToString() {<br/> return namesOfFaces[getFaceValue()] + " of " + namesOfSuits[getSuitValue()];<br/>}</code></pre></p> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#include "Deck.h"<br/>#include "Card.h"<br/>#include &#60vector&#62<br/>Deck::Deck() {<br/> for (size_t cardSuit = 0; cardSuit < 4; ++cardSuit) for (size_t cardFace = 0; cardFace < 13; ++cardFace) Deck::theDeckOfCards.emplace_back(Card{ cardSuit, cardFace });<br/> indexOfNextCard = 0;<br/>}<br/><br/>void Deck::shuffleTheDeck() {<br/> for (size_t shuffleCount = 0; shuffleCount < 250; shuffleCount++) {<br/> size_t x = rand() % 52;<br/> size_t y = rand() % 52;<br/> Card temp(0, 0);<br/> temp = theDeckOfCards[x];<br/> theDeckOfCards[x] = theDeckOfCards[y];<br/> theDeckOfCards[y] = temp;<br/> }<br/> indexOfNextCard = 0;<br/>}<br/>Card Deck::dealOneCard() {<br/> return theDeckOfCards[indexOfNextCard++];<br/>}<br/><br/>bool Deck::cardsLeft() {<br/> return (51 >= indexOfNextCard);<br/>}</code></pre></p> <p><pre><code>// Caden Roberts 10/29/22 CIST004A<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include "Card.h"<br/>#include "Deck.h"<br/>int main() {<br/> int i{ 1 };<br/> std::cout << "Caden Roberts\t10/29/22\tCIST004A\n";<br/> Deck theDeckOfCards;<br/> do {<br/> std::cout << '\n';<br/> for (int j = i; j > 0; j--) theDeckOfCards.shuffleTheDeck();<br/> int counter{ 1 };<br/> while (theDeckOfCards.cardsLeft()) {<br/> std::cout << std::left << std::setw(20) << (theDeckOfCards.dealOneCard()).cardToString();<br/> if (counter++ % 4 == 0) std::cout << '\n';<br/> }<br/> std::cout << "\nEnter # of times to shuffle again, or enter any non-integer key to exit : ";<br/> std::cin >> i;<br/> } while (!std::cin.fail());<br/> return 0;<br/>}</code></pre></p> <!-- Pointers and C-String Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Pointers and C-String Program</h3> <p> Output is a menu of self-defined options to perform on an inputted string.</p></blockquote> <p><pre><code>// Caden Roberts CIST004A 10/13/22<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>#include &#60ctype.h&#62<br/>using namespace std;<br/><br/>int countCharacters(char * sPtr) {<br/> int count{0};<br/> for (;* sPtr != '\0'; ++sPtr, ++count) {}<br/> return count;<br/>}<br/><br/>int countVowels(char * sPtr) {<br/> int vowelCount{0};<br/> for (;* sPtr != '\0'; ++sPtr) switch (toupper( * sPtr)) {<br/> case 'A':<br/> case 'E':<br/> case 'I':<br/> case 'O':<br/> case 'U':<br/> ++vowelCount;<br/> }<br/> return vowelCount;<br/>}<br/><br/>void firstUpper(char * sPtr) {<br/> * sPtr = toupper( * sPtr);<br/> for (;* sPtr != '\0'; ++sPtr) if ( * sPtr == ' ') * (sPtr + 1) = toupper( * (sPtr + 1));<br/>}<br/><br/>void shout(char * sPtr) {<br/> for (;* sPtr != '\0';* sPtr++ = toupper( * sPtr)) {}<br/>}<br/><br/>void removeSpaces(char * sPtr) {<br/> char * dPtr = sPtr;<br/> for (;* sPtr != '\0';* dPtr++ = * sPtr++) while ( * sPtr == ' ' and * (sPtr + 1) == ' ') sPtr++;<br/> * dPtr = '\0';<br/>}<br/><br/>int main() {<br/> cout << "CADEN ROBERTS\tCIST004A\t10/22/22\n";<br/> char String[80];<br/> int Operation {6};<br/> int i{0};<br/> do {<br/> if (i > 0) {<br/> cout << "\nSelect operation to perform on this string.\n1\tCount the characters in the string.\n2\tCount the vowels in the string.\n3\tUppercase the first character of each word in the string.\n4\tUppercase every character in the string.\n5\tRemove extra spaces in the string.\n6\tEnter a new string.\n0\tExit this program.\nEnter Operation: ";<br/> cin >> Operation;<br/> if (cin.fail() or cin.peek() != '\n') {<br/> Operation = 7;<br/> cin.clear();<br/> cin.ignore(1000, '\n');<br/> }<br/> }<br/> switch (Operation) {<br/> case 1:<br/> cout << "\nThere are " << countCharacters(String) << " characters in: \"" << String << "\"\n";<br/> break;<br/> case 2:<br/> cout << "\nThere are " << countVowels(String) << " vowels in: \"" << String << "\"\n";<br/> break;<br/> case 3:<br/> firstUpper(String);<br/> cout << "\nUpper case first letters: \"" << String << "\".\n";<br/> break;<br/> case 4:<br/> shout(String);<br/> cout << "\nShouting: \"" << String << "\".\n";<br/> break;<br/> case 5:<br/> removeSpaces(String);<br/> cout << "\nExtra spaces removed: \"" << String << "\".\n";<br/> break;<br/> case 6:<br/> if (i++ > 0) {<br/> cin.clear();<br/> cin.ignore(1000, '\n');<br/> }<br/> cout << "\nEnter a String: ";<br/> cin.getline(String, 80);<br/> break;<br/> case 0:<br/> break;<br/> default:<br/> cout << "\nInvalid Operation Request.\n";<br/> }<br/> } while (Operation != 0);<br/> return 0;<br/>}</code></pre></p> <!-- Statistical Anlysis of Dice Rolls Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Statistical Anlysis of Dice Rolls Program</h3> <p> Output is all possible values rolled and their frequencies respresented by astriks scaled to each set of data.</p></blockquote> <p><pre><code>// Caden Roberts CIST004A 10/13/22<br/>#include &#60iostream&#62<br/>#include &#60vector&#62<br/>#include &#60iomanip&#62<br/>#include &#60string&#62<br/>using namespace std;<br/>int main() {<br/> int numberOfDice{ 0 };<br/> int numberOfFaces{ 0 };<br/> int numberOfRolls{ 0 };<br/> int max{ 0 };<br/> vector &#60int&#62 diceCounter;<br/> cout << "CADEN ROBERTS\tCIST004A\t10/13/22\n\n";<br/> do {<br/> cout << "Enter the number of Dice (at least 1): ";<br/> cin >> numberOfDice;<br/> if (cin.peek() != '\n' or cin.fail()) {<br/> numberOfDice = 0; cin.clear(); cin.ignore(1000, '\n');<br/> }<br/> } while (numberOfDice < 1);<br/> do {<br/> cout << "Enter the number of faces on each dice (at least 2): ";<br/> cin >> numberOfFaces;<br/> if (cin.peek() != '\n' or cin.fail()) {<br/> numberOfFaces = 0; cin.clear(); cin.ignore(1000, '\n');<br/> }<br/> } while (numberOfFaces < 2);<br/> do {<br/> cout << "Enter the number of Rolls (at least 1): ";<br/> cin >> numberOfRolls;<br/> if (cin.peek() != '\n' or cin.fail()) {<br/> numberOfRolls = 0; cin.clear(); cin.ignore(1000, '\n');<br/> }<br/> } while (numberOfRolls < 1);<br/> diceCounter.resize(numberOfDice * numberOfFaces + 1, 0);<br/> for (int i = 0; i < numberOfRolls; i++) {<br/> int rollTotal = 0;<br/> for (int i = 0; i < numberOfDice; i++) rollTotal += 1 + rand() % numberOfFaces;<br/> diceCounter.at(rollTotal)++;<br/> }<br/> for (int i : diceCounter) max = max > i ? max : i;<br/> for (int i = numberOfDice; i < diceCounter.size(); ++i) {<br/> cout << "Rolled " + to_string(i) << setw(12-to_string(i).length());<br/> int stars = (diceCounter.at(i) * 40 / max);<br/> for (int i = 0; i < stars; i++) cout << '*';<br/> cout << '\n';<br/> }<br/> return 0;<br/>}</code></pre></p> <!-- Prime Factor Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Factorial Recursive Program with CTIME test</h3><p>Ouput is all prime factors of a number, as well as the time it takes to run the primeFactor(number) call</p></blockquote> <p><pre><code>// Caden Roberts CIST004A 10/03/22<br/>#include &#60iostream&#62<br/>#include &#60ctime&#62<br/>void primeFactor (unsigned int num, unsigned int div=2 ){<br/> if (num == div){<br/> std::cout << div << " ";<br/> return;<br/> }<br/> if ( num % div == 0 ){<br/> std::cout << div << ", " ;<br/> primeFactor (num/div, div);<br/> } else primeFactor (num, div+1);<br/> return;<br/>}<br/><br/>int main() {<br/> unsigned int number;<br/> time_t startTime;<br/> double deltaTimeMS;<br/> std::cout << "Enter a number to factor: ";<br/> std::cin >> number;<br/> std::cout << "The prime factors are: ";<br/> startTime = clock();<br/> primeFactor (number);<br/> deltaTimeMS = static_cast<double>(clock() - startTime) *1000.0 / CLOCKS_PER_SEC;<br/> std::cout << "\nThis took " << deltaTimeMS << " mSec." << std::endl;<br/> return 0;<br/>}</code></pre></p> <!-- College GPA Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">College GPA Program</h3><p>Output is your gpa as well as other comments related to particular inputs.</p></blockquote> <p><pre><code>// Caden Roberts CIST004A 9/30/22<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>using namespace std;<br/>float GPA{0}, Low{4.0f}, High{0}, Average{0};<br/>int n{1};<br/>// enter -1 to indicate you are done adding student GPAs<br/>int main() {<br/> cout << "Caden Roberts CIST004A 9/30/22\n\nIntermediate GPA Calc Program\n\nTo calculate your GPA, enter each letter grade in either upper or lower case with an optional + or - followed by the [Return] key. (If you have no more grades, enter z followed by the [Return] key.) Next, enter the number of units for the course followed by the [Return] key.\n";<br/> do {<br/> cout << "\nPlease Enter Grade for Class " << CLASS << " (Z to exit): ";<br/> cin >> GradeInput;<br/> if (cin.peek() != '\n') cin.get(GradeMod);<br/> if ((GradeInput == '-') or (GradeInput == '+')) {<br/> swap(GradeInput, GradeMod);<br/> cout << "Watch where you put the +/-!\n";<br/> }<br/> GradeInput = toupper(GradeInput);<br/> switch (GradeInput) {<br/> case 'A':<br/> GradePoints = 4.0f;<br/> break;<br/> case 'B':<br/> GradePoints = 3.0f;<br/> break;<br/> case 'C':<br/> GradePoints = 2.0f;<br/> break;<br/> case 'D':<br/> GradePoints = 1.0f;<br/> break;<br/> case 'F':<br/> GradePoints = 0.0f;<br/> break;<br/> case 'Z':<br/> GradePoints = 0.0f;<br/> continue;<br/> default:<br/> cout << "Please Enter a Valid Letter Grade (A,B,C,D,F)\n";<br/> continue;<br/> }<br/> switch (GradeMod) {<br/> case '+':<br/> if (GradeInput == 'F') cout << "We'll throw you a bone on the F+!\n";<br/> if (GradeInput != 'A') GradePoints = GradePoints + 0.3f;<br/> else cout << "An A+ will score no better than an A!\n";<br/> break;<br/> case '-':<br/> if (GradeInput != 'F') GradePoints = GradePoints - 0.3f;<br/> else cout << "Luckily, an F is the lowest you can go!\n";<br/> break;<br/> case ' ':<br/> break;<br/> default:<br/> cout << "Please Enter Valid Grade Sign Modifier (+/-/ )\n";<br/> continue;<br/> }<br/> CreditHours = 0.0f;<br/> while ((CreditHours < 0.5f) or (CreditHours > 45.0f)) {<br/> cout << "\nPlease Enter Credit hours for Class " << CLASS << ": ";<br/> cin >> ws;<br/> cin >> CreditHours;<br/> if (cin.fail()) {<br/> cin.clear();<br/> cin.ignore(1000, '\n');<br/> CreditHours = 0.0f;<br/> }<br/> if ((CreditHours < 0.5f) or (CreditHours > 45.0f)) cout << "Please enter a valid # of Credit hours for class " << CLASS << "(0.5-45)\n";<br/> }<br/> GradePoints = GradePoints * CreditHours;<br/> TGP = TGP + GradePoints;<br/> TCH = TCH + CreditHours;<br/> GPA = TGP / TCH;<br/> CLASS++;<br/> } while (GradeInput != 'Z');<br/> if (CLASS - 1 == 0) cout << "\nNo Valid Classes Entered.";<br/> else {<br/> if (CLASS - 1 == 1) cout << "\nYour GPA for the 1 valid class entry is ";<br/> else cout << "\nYour GPA for the " << CLASS - 1 << " valid class entries is ";<br/> cout << fixed << setprecision(3) << GPA << "\n";<br/> }<br/> return 0;<br/>}</code></pre></p> <!-- GPA MINMAXAVE Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">GPA Min/Max/Ave Program</h3><p>Output is your gpa as well as other comments related to particular inputs.</p></blockquote> <p><pre><code>// Caden Roberts CIST004A 9/30/22<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>using namespace std;<br/>float GPA{0}, Low{4.0f}, High{0}, Average{0};<br/>int n{1};<br/>// enter -1 to indicate you are done adding student GPAs<br/>int main() {<br/> cout << "Caden Roberts CIST004A 9/13/22\n";<br/> while (GPA != -1.0f) {<br/> cout << "\nEnter a GPA (0.0-4.0) for Student #" << n << ": ";<br/> cin >> GPA;<br/> while (GPA > 4.0f || GPA < 0.0f && GPA != -1.0f) {<br/> cout << "\nEnter a valid GPA (0.0-4.0) for Student #" << n << ": ";<br/> cin >> GPA;<br/> }<br/> if (GPA == -1.0f) continue;<br/> Low = Low < GPA ? Low : GPA;<br/> High = High > GPA ? High : GPA;<br/> Average = Average + GPA;<br/> n++;<br/> }<br/> Average = Average / (n - 1);<br/> cout << fixed << setprecision(3) << "\n\nThe lowest GPA entered was: " << Low << "\n\nThe highest GPA entered was: " << High << "\n\nThe average GPA was: " << Average << "\n";<br/> return 0;<br/>}</code></pre></p> <!-- Health Record Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Health Record Program</h3><p>Output is a comparison of who between Person 1 and 2 is "healthier".</p></blockquote> <p><pre><code>// Caden Roberts CIST004A 9/13/22<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>using namespace std;<br/>float computeBMI (float height, float weight){<br/> return ((weight/2.20462f)/((height*2.540f/100.0f)*(height*2.540f/100.0f)));<br/>}<br/><br/>float Height1, Height2, Weight1, Weight2, BMI1, BMI2;<br/>string Person1, Person2;<br/><br/>int main() {<br/> cout << "Caden Roberts CIST004A\n\nPlease Enter The First Person's Name: ";<br/> getline (cin, Person1);<br/> cout << "Please Enter " << Person1 << "'s height in inches: ";<br/> cin >> Height1;<br/> cout << "Please Enter " << Person1 << "'s weight in pounds: ";<br/> cin >> Weight1;<br/> cout << "\nPlease Enter The Second Person's Name: ";<br/> getline (cin >> ws, Person2);<br/> cout << "Please Enter " << Person2 << "'s height in inches: ";<br/> cin >> Height2;<br/> cout << "Please Enter " << Person2 << "'s weight in pounds: ";<br/> cin >> Weight2;<br/> BMI1 = computeBMI (Height1, Weight1);<br/> BMI2 = computeBMI (Height2, Weight2);<br/> cout << "\n" << Person1 << "'s BMI is " << BMI1 << ".\n" << Person2 << "'s BMI is " << BMI2 << ".\n";<br/> if(BMI1 < BMI2) cout << Person1 << " is 'healthier' than " << Person2 << ".\n";<br/> else if(BMI2 < BMI1) cout << Person2 << " is 'healthier' than " << Person1 << ".\n";<br/> else cout << Person1 << " is equally as 'healthy' as " << Person2 << ".\n";<br/> return 0;<br/>}</code></pre></p> <!-- Height+Weight Program --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Height+Weight Program (Data test of type precision at bottom for EC as well)</h3><p>Output is your Height, Weight, BMI, and snarky comments.</p></blockquote> <p><pre><code>// Caden Roberts CIST004A 9/1/22<br/>#include &#60iostream&#62<br/>#include &#60iomanip&#62<br/>float Height, Weight, BMI;</br>using namespace std;<br/>int main() {<br/> cout << "Caden Roberts CIST004A\nPlease Enter Height in Inches: ";<br/> cin >> Height;<br/> Height = Height*2.540f/100.0f;<br/> cout << "Please Enter Weight in Pounds: ";<br/> cin >> Weight;<br/> Weight = Weight / 2.20462f;<br/> BMI = (Weight/(Height*Height));<br/> cout << "Your height is " << Height << " meters.\n";<br/> if(Height <= 0.3f) cout << "If you aren't 2 years old, you may have a world record!\n";<br/> if(Height >= 2.1336f) cout << "You should call the Lakers Immediately.\n";<br/> cout << "Your weight is " << Weight << " kilograms.\n";<br/> if(Weight <= 23.0f) cout << "Pick up the cheetos!!\n";<br/> if(Weight >= 182.0f) cout << "Put the cheetos down!!\n";<br/> cout << "Your BMI is " << BMI << ".\n";<br/> if(BMI < 18.0f) cout << "You are underweight.\n";<br/> else if(BMI < 25.0f) cout << "You are a healthy weight.\n";<br/> else if(BMI < 30.0f) cout << "You are overweight.\n";<br/> else if(BMI < 40.0f) cout << "You are obese.\n";<br/> else cout << "You are extremely obese.\n";<br/> double test1 = 1.0/3.0;<br/> float test2 = 1.0f/3.0f;<br/> long double test3 = 1.0L/3.0L;<br/> cout << setprecision(25) << "double result: " << test1 << "\nfloat result: " << test2 << "\nlong double result: " << test3 << "\n";<br/> return 0;<br/>}</code></pre></p> </div> </div> <!-- Hello World --> <div class="wrapper"> <div class = "inner"> <blockquote><h3 class="major">Hello World</h3><p>Output is Name, Class, and Hello World!</p></blockquote> <p><pre><code>//Hello World Assignment<br/>//Caden Roberts 9/1/22 CIST004A<br/>#include &#60iostream&#62<br/>using namespace std;<br/>int main(int argc, const char * argv[]) {<br/>cout << "Caden Roberts CIST004A\n";<br/>cout << "Hello World!\n";<br/>return 0;<br/>}</code></pre></p> </div> </div> <!-- Footer --> <section id="footer"> <div class="inner"> <h2 class="major">Get in touch</h2> <p>Contact me by phone or email preferrably. I've also included my LinkedIn, network with me!</p> <ul class="contact"> <li class="icon solid fa-home"> 5289 Meridian Avenue<br /> San Jose, CA 95118 </li> <li class="icon solid fa-phone"><a href="sms:4085999701?body=Hey%20Caden!">(408) 599-9701</a></li> <li class="icon solid fa-envelope"><a href="mailto:cadenroberts@icloud.com">cadenroberts@icloud.com</a></li> <li class="icon brands fa-linkedin"><a href="https://www.linkedin.com/in/caden-roberts-868631189">https://www.linkedin.com/in/caden-roberts-868631189</a></li></ul></div></section></div> <!-- Scripts --> <script src="assets/js/jquery.min.js"></script> <script src="assets/js/jquery.scrollex.min.js"></script> <script src="assets/js/browser.min.js"></script> <script src="assets/js/breakpoints.min.js"></script> <script src="assets/js/util.js"></script> <script src="assets/js/main.js"></script></body></html>
